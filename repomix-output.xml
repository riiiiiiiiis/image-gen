This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
app/
  api/
    categorize-vocabulary/
      route.ts
    clear-queue/
      route.ts
    gallery/
      route.ts
    generate-image/
      route.ts
    generate-images-batch/
      route.ts
    generate-prompt/
      route.ts
    generate-prompts-batch/
      route.ts
    language-cards/
      route.ts
    queue-image/
      route.ts
    random-pending-word/
      route.ts
    test-categorization/
      route.ts
    test-gemini/
      route.ts
    upload/
      route.ts
  globals.css
  layout.tsx
  page.tsx
  theme.css
components/
  ActivityLog.tsx
  ASCIILogo.tsx
  BatchActionMenu.tsx
  DataTable.tsx
  DemoButton.tsx
  FileUpload.tsx
  Gallery.tsx
  QueueStatus.tsx
data/
  gallery.json
lib/
  db/
    migrations/
      002_add_categorization.ts
    database.ts
    migrations.ts
    repository.ts
    runMigrations.ts
    schema.ts
  aiUtils.ts
  apiClient.ts
  apiUtils.ts
  batchUtils.ts
  gemini.ts
  imageQueue.ts
  imageUtils.ts
  openrouter.server.ts
  openrouter.ts
  paths.ts
  promptOverrides.ts
  replicateConfig.ts
  supabaseAdmin.ts
  supabaseImageStorage.ts
  vercelBlobUpload.ts
scripts/
  download-failed-images.js
  export-all-images-by-qa.js
  export-good-images.js
  export-non-good-images.js
store/
  useAppStore.ts
supabase/
  .gitignore
  config.toml
types/
  index.ts
utils/
  migrate-to-sqlite.ts
.eslintrc.json
.gitignore
CLAUDE.md
next.config.ts
package.json
plan.md
postcss.config.mjs
prompt_overrides.yaml
RANDOM_WORD_API_OPTIMIZATION.md
README.md
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "mcp__context7__resolve-library-id",
      "mcp__context7__get-library-docs",
      "Bash(git add:*)",
      "Bash(mkdir:*)",
      "Bash(npm run build:*)",
      "Bash(ls:*)"
    ],
    "deny": []
  },
  "enableAllProjectMcpServers": false
}
</file>

<file path="scripts/download-failed-images.js">
#!/usr/bin/env node

const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const path = require('path');
const https = require('https');
const http = require('http');
require('dotenv').config({ path: path.join(__dirname, '..', '.env.local') });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('‚ùå Missing Supabase environment variables');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

const OUTPUT_DIR = path.join(__dirname, '..', 'good-images-export');
const IMAGES_DIR = path.join(OUTPUT_DIR, 'images');

// Failed image IDs
const FAILED_IDS = [8846, 8012, 8428, 8020, 8499];

function downloadImage(url, filepath) {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https:') ? https : http;
    
    const request = client.get(url, (response) => {
      if (response.statusCode === 200) {
        const fileStream = fs.createWriteStream(filepath);
        response.pipe(fileStream);
        
        fileStream.on('finish', () => {
          fileStream.close();
          resolve();
        });
        
        fileStream.on('error', (err) => {
          fs.unlink(filepath, () => {});
          reject(err);
        });
      } else {
        reject(new Error(`Failed to download image. Status code: ${response.statusCode}`));
      }
    });
    
    request.on('error', (err) => {
      reject(err);
    });
    
    // Increase timeout to 60 seconds for these problematic images
    request.setTimeout(60000, () => {
      request.abort();
      reject(new Error('Download timeout'));
    });
  });
}

async function main() {
  console.log('üöÄ Downloading failed images...');
  console.log(`üìã IDs to download: ${FAILED_IDS.join(', ')}`);
  
  // Query database for these specific images
  const { data: entries, error } = await supabase
    .from('word_entries')
    .select('id, original_text, translation_text, image_url')
    .in('id', FAILED_IDS);
  
  if (error) {
    console.error('‚ùå Database query failed:', error);
    process.exit(1);
  }
  
  if (!entries || entries.length === 0) {
    console.log('‚ÑπÔ∏è No entries found for these IDs');
    return;
  }
  
  console.log(`üìä Found ${entries.length} entries in database`);
  
  // Download each image
  for (const entry of entries) {
    const filename = `${entry.id}.png`;
    const filepath = path.join(IMAGES_DIR, filename);
    
    console.log(`‚¨áÔ∏è Downloading ${filename}...`);
    
    try {
      await downloadImage(entry.image_url, filepath);
      console.log(`‚úÖ Successfully downloaded ${filename}`);
    } catch (error) {
      console.error(`‚ùå Failed to download ${filename}: ${error.message}`);
    }
  }
  
  console.log('\nüéâ Finished!');
}

main().catch((error) => {
  console.error('üí• Unexpected error:', error);
  process.exit(1);
});
</file>

<file path="scripts/export-all-images-by-qa.js">
#!/usr/bin/env node

const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const path = require('path');
const https = require('https');
const http = require('http');
require('dotenv').config({ path: path.join(__dirname, '..', '.env.local') });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('‚ùå Missing Supabase environment variables');
  console.error('Make sure NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are set in .env.local');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

const OUTPUT_DIR = path.join(__dirname, '..', 'images-export-by-qa');

function createDirectories() {
  // Create main output directory
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }
  
  // Create subdirectories for each qa_score
  const subdirs = ['good', 'bad', 'unrated'];
  subdirs.forEach(subdir => {
    const dirPath = path.join(OUTPUT_DIR, subdir);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  });
}

function getQAFolder(qa_score) {
  if (qa_score === 'good') return 'good';
  if (qa_score === 'bad') return 'bad';
  return 'unrated'; // null or undefined qa_score
}

function downloadImage(url, filepath) {
  return new Promise((resolve, reject) => {
    // Skip if file already exists
    if (fs.existsSync(filepath)) {
      resolve({ skipped: true });
      return;
    }
    
    const client = url.startsWith('https:') ? https : http;
    
    const request = client.get(url, (response) => {
      if (response.statusCode === 200) {
        const fileStream = fs.createWriteStream(filepath);
        response.pipe(fileStream);
        
        fileStream.on('finish', () => {
          fileStream.close();
          resolve({ skipped: false });
        });
        
        fileStream.on('error', (err) => {
          fs.unlink(filepath, () => {}); // Delete the file on error
          reject(err);
        });
      } else {
        reject(new Error(`Failed to download image. Status code: ${response.statusCode}`));
      }
    });
    
    request.on('error', (err) => {
      reject(err);
    });
    
    request.setTimeout(30000, () => {
      request.abort();
      reject(new Error('Download timeout'));
    });
  });
}


async function downloadWithConcurrency(downloadTasks, concurrency = 5) {
  const results = [];
  let index = 0;
  let skippedCount = 0;
  
  async function downloadNext() {
    if (index >= downloadTasks.length) return;
    
    const currentIndex = index++;
    const task = downloadTasks[currentIndex];
    
    try {
      const result = await downloadImage(task.url, task.filepath);
      if (result.skipped) {
        skippedCount++;
        console.log(`‚è≠Ô∏è  Skipped ${currentIndex + 1}/${downloadTasks.length}: ${task.filename} (already exists)`);
      } else {
        console.log(`‚úÖ Downloaded ${currentIndex + 1}/${downloadTasks.length}: ${task.filename} ‚Üí ${task.folder}/`);
      }
      results.push({ success: true, task, skipped: result.skipped });
    } catch (error) {
      console.error(`‚ùå Failed ${currentIndex + 1}/${downloadTasks.length}: ${task.filename} - ${error.message}`);
      results.push({ success: false, task, error });
    }
    
    // Download next task
    await downloadNext();
  }
  
  // Start concurrent downloads
  const workers = Array(Math.min(concurrency, downloadTasks.length))
    .fill()
    .map(() => downloadNext());
  
  await Promise.all(workers);
  return { results, skippedCount };
}

async function main() {
  console.log('üöÄ Starting export of all images organized by QA score...');
  
  // Create output directories
  createDirectories();
  console.log(`üìÅ Created output directory: ${OUTPUT_DIR}`);
  console.log('üìÇ Subdirectories: good/, bad/, unrated/');
  
  // Query database for all images
  console.log('üîç Querying database for all images...');
  const { data: entries, error } = await supabase
    .from('word_entries')
    .select('id, original_text, translation_text, image_url, qa_score')
    .not('image_url', 'is', null)
    .limit(5000);
  
  if (error) {
    console.error('‚ùå Database query failed:', error);
    process.exit(1);
  }
  
  if (!entries || entries.length === 0) {
    console.log('‚ÑπÔ∏è No images found in database');
    return;
  }
  
  console.log(`üìä Found ${entries.length} total images to export`);
  
  // Count by qa_score
  const scoreCounts = entries.reduce((acc, entry) => {
    const score = entry.qa_score || 'unrated';
    acc[score] = (acc[score] || 0) + 1;
    return acc;
  }, {});
  
  console.log('üìà Breakdown by qa_score:');
  Object.entries(scoreCounts).forEach(([score, count]) => {
    console.log(`   ${score}: ${count}`);
  });
  
  // Prepare download tasks
  const downloadTasks = entries.map((entry) => {
    const folder = getQAFolder(entry.qa_score);
    const filename = `${entry.id}.png`;
    const filepath = path.join(OUTPUT_DIR, folder, filename);
    
    return {
      id: entry.id,
      url: entry.image_url,
      filename,
      filepath,
      folder,
      original: entry.original_text,
      translation: entry.translation_text,
      qa_score: entry.qa_score
    };
  });
  
  // Start downloads
  console.log('‚¨áÔ∏è Starting downloads (5 concurrent)...');
  const { results, skippedCount } = await downloadWithConcurrency(downloadTasks, 5);
  
  // Summary
  const successful = results.filter(r => r.success && !r.skipped).length;
  const failed = results.filter(r => !r.success).length;
  
  console.log('\nüìà Export Summary:');
  console.log(`‚úÖ Successful downloads: ${successful}`);
  console.log(`‚è≠Ô∏è  Skipped (already exist): ${skippedCount}`);
  console.log(`‚ùå Failed: ${failed}`);
  console.log(`üìÅ Images saved to: ${OUTPUT_DIR}`);
  console.log('   ‚îî‚îÄ‚îÄ good/    (good quality images)');
  console.log('   ‚îî‚îÄ‚îÄ bad/     (bad quality images)');
  console.log('   ‚îî‚îÄ‚îÄ unrated/ (unrated images)');
  
  if (failed > 0) {
    console.log('\n‚ùå Failed downloads:');
    results
      .filter(r => !r.success)
      .forEach(r => console.log(`   ${r.task.filename}: ${r.error.message}`));
  }
  
  console.log('\nüéâ Export completed!');
}

main().catch((error) => {
  console.error('üí• Unexpected error:', error);
  process.exit(1);
});
</file>

<file path="scripts/export-non-good-images.js">
#!/usr/bin/env node

const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const path = require('path');
const https = require('https');
const http = require('http');
require('dotenv').config({ path: path.join(__dirname, '..', '.env.local') });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('‚ùå Missing Supabase environment variables');
  console.error('Make sure NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are set in .env.local');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

const OUTPUT_DIR = path.join(__dirname, '..', 'non-good-images-export');
const IMAGES_DIR = path.join(OUTPUT_DIR, 'images');

function createDirectories() {
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }
  if (!fs.existsSync(IMAGES_DIR)) {
    fs.mkdirSync(IMAGES_DIR, { recursive: true });
  }
}

function downloadImage(url, filepath) {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https:') ? https : http;
    
    const request = client.get(url, (response) => {
      if (response.statusCode === 200) {
        const fileStream = fs.createWriteStream(filepath);
        response.pipe(fileStream);
        
        fileStream.on('finish', () => {
          fileStream.close();
          resolve();
        });
        
        fileStream.on('error', (err) => {
          fs.unlink(filepath, () => {}); // Delete the file on error
          reject(err);
        });
      } else {
        reject(new Error(`Failed to download image. Status code: ${response.statusCode}`));
      }
    });
    
    request.on('error', (err) => {
      reject(err);
    });
    
    request.setTimeout(30000, () => {
      request.abort();
      reject(new Error('Download timeout'));
    });
  });
}


async function downloadWithConcurrency(downloadTasks, concurrency = 5) {
  const results = [];
  let index = 0;
  
  async function downloadNext() {
    if (index >= downloadTasks.length) return;
    
    const currentIndex = index++;
    const task = downloadTasks[currentIndex];
    
    try {
      await downloadImage(task.url, task.filepath);
      console.log(`‚úÖ Downloaded ${currentIndex + 1}/${downloadTasks.length}: ${task.filename} (${task.qa_score || 'unrated'})`);
      results.push({ success: true, task });
    } catch (error) {
      console.error(`‚ùå Failed ${currentIndex + 1}/${downloadTasks.length}: ${task.filename} - ${error.message}`);
      results.push({ success: false, task, error });
    }
    
    // Download next task
    await downloadNext();
  }
  
  // Start concurrent downloads
  const workers = Array(Math.min(concurrency, downloadTasks.length))
    .fill()
    .map(() => downloadNext());
  
  await Promise.all(workers);
  return results;
}

async function main() {
  console.log('üöÄ Starting export of non-good images...');
  
  // Create output directories
  createDirectories();
  console.log(`üìÅ Created output directory: ${OUTPUT_DIR}`);
  
  // Query database for non-good images (including unrated)
  console.log('üîç Querying database for non-good images (including unrated)...');
  const { data: entries, error } = await supabase
    .from('word_entries')
    .select('id, original_text, translation_text, image_url, qa_score')
    .or('qa_score.neq.good,qa_score.is.null')
    .not('image_url', 'is', null)
    .limit(5000);
  
  if (error) {
    console.error('‚ùå Database query failed:', error);
    process.exit(1);
  }
  
  if (!entries || entries.length === 0) {
    console.log('‚ÑπÔ∏è No non-good images found in database');
    return;
  }
  
  console.log(`üìä Found ${entries.length} non-good images to export`);
  
  // Count by qa_score
  const scoreCounts = entries.reduce((acc, entry) => {
    const score = entry.qa_score || 'unrated';
    acc[score] = (acc[score] || 0) + 1;
    return acc;
  }, {});
  
  console.log('üìà Breakdown by qa_score:');
  Object.entries(scoreCounts).forEach(([score, count]) => {
    console.log(`   ${score}: ${count}`);
  });
  
  // Prepare download tasks
  const downloadTasks = entries.map((entry) => {
    const filename = `${entry.id}.png`;
    const filepath = path.join(IMAGES_DIR, filename);
    
    return {
      id: entry.id,
      url: entry.image_url,
      filename,
      filepath,
      original: entry.original_text,
      translation: entry.translation_text,
      qa_score: entry.qa_score
    };
  });
  
  // Start downloads
  console.log('‚¨áÔ∏è Starting downloads (5 concurrent)...');
  const results = await downloadWithConcurrency(downloadTasks, 5);
  
  // Summary
  const successful = results.filter(r => r.success).length;
  const failed = results.filter(r => !r.success).length;
  
  console.log('\nüìà Export Summary:');
  console.log(`‚úÖ Successful: ${successful}`);
  console.log(`‚ùå Failed: ${failed}`);
  console.log(`üìÅ Images saved to: ${IMAGES_DIR}`);
  
  if (failed > 0) {
    console.log('\n‚ùå Failed downloads:');
    results
      .filter(r => !r.success)
      .forEach(r => console.log(`   ${r.task.filename}: ${r.error.message}`));
  }
  
  console.log('\nüéâ Export completed!');
}

main().catch((error) => {
  console.error('üí• Unexpected error:', error);
  process.exit(1);
});
</file>

<file path="app/api/clear-queue/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { imageQueue } from '@/lib/imageQueue';
import { handleApiRequest } from '@/lib/apiUtils';

export async function POST(request: NextRequest) {
  return handleApiRequest(request, async () => {
    const clearedCount = imageQueue.clearQueue();
    
    return NextResponse.json({
      success: true,
      message: `Cleared ${clearedCount} items from the image generation queue`,
      clearedCount
    });
  });
}
</file>

<file path="app/api/upload/route.ts">
import { NextResponse } from 'next/server';
import { uploadFileToBlob } from '@/lib/vercelBlobUpload';

export async function POST(request: Request) {
  const formData = await request.formData();
  const file = formData.get('file') as File | null;

  if (!file) {
    return NextResponse.json({ error: 'No file provided.' }, { status: 400 });
  }

  try {
    // Construct a unique filename, e.g., using entryId or a timestamp if not available from client
    // For now, using original file.name, but for programmatic uploads, you'll generate this.
    const fileName = `uploads/${Date.now()}-${file.name}`;
    const url = await uploadFileToBlob(fileName, file);
    return NextResponse.json({ url });
  } catch (error) {
    console.error('Upload API error:', error);
    return NextResponse.json({ error: 'Failed to upload file.' }, { status: 500 });
  }
}
</file>

<file path="app/theme.css">
@theme {
  /* Colors */
  --color-notion-gray-50: #FAFAFA;
  --color-notion-gray-100: #F7F7F7;
  --color-notion-gray-200: #E5E5E5;
  --color-notion-gray-300: #D4D4D4;
  --color-notion-gray-400: #A3A3A3;
  --color-notion-gray-500: #737373;
  --color-notion-gray-600: #525252;
  --color-notion-gray-700: #404040;
  --color-notion-gray-800: #262626;
  --color-notion-gray-900: #171717;
  
  --color-notion-blue: #0066CC;
  --color-notion-green: #10B981;
  --color-notion-red: #EF4444;
  
  /* Font Family */
  --font-family-sans: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  
  /* Custom Spacing */
  --spacing-18: 4.5rem;
  --spacing-88: 22rem;
  
  /* Border Radius */
  --radius-notion: 6px;
  
  /* Box Shadow */
  --shadow-notion: 0 1px 3px rgba(0,0,0,0.1);
  --shadow-notion-hover: 0 2px 8px rgba(0,0,0,0.15);
}
</file>

<file path="components/ActivityLog.tsx">
'use client';

import { useState, useEffect } from 'react';
import { X, AlertCircle, CheckCircle, Loader2, Info } from 'lucide-react';

export interface ActivityItem {
  id: string;
  type: 'info' | 'success' | 'error' | 'loading';
  message: string;
  details?: string;
  timestamp: Date;
  operationKey?: string; // To track related operations
}

interface ActivityLogProps {
  maxItems?: number;
}

// Global activity manager
class ActivityManager {
  private listeners: ((items: ActivityItem[]) => void)[] = [];
  private items: ActivityItem[] = [];
  private maxItems: number = 10;

  subscribe(listener: (items: ActivityItem[]) => void) {
    this.listeners.push(listener);
    listener(this.items);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  addActivity(type: ActivityItem['type'], message: string, details?: string, operationKey?: string) {
    const newItem: ActivityItem = {
      id: `${Date.now()}-${Math.random()}`,
      type,
      message,
      details,
      timestamp: new Date(),
      operationKey,
    };

    // If this is an error/success for an operation, remove any loading messages for the same operation
    if ((type === 'error' || type === 'success') && operationKey) {
      this.items = this.items.filter(item => 
        !(item.type === 'loading' && item.operationKey === operationKey)
      );
    }

    this.items = [newItem, ...this.items].slice(0, this.maxItems);
    this.notifyListeners();

    // Auto-remove success messages after 5 seconds
    if (type === 'success') {
      setTimeout(() => {
        this.removeActivity(newItem.id);
      }, 5000);
    }
  }

  removeActivity(id: string) {
    this.items = this.items.filter(item => item.id !== id);
    this.notifyListeners();
  }

  clearAll() {
    this.items = [];
    this.notifyListeners();
  }

  private notifyListeners() {
    this.listeners.forEach(listener => listener(this.items));
  }
}

export const activityManager = new ActivityManager();

export default function ActivityLog({ maxItems = 5 }: ActivityLogProps) {
  const [activities, setActivities] = useState<ActivityItem[]>([]);
  const [isExpanded, setIsExpanded] = useState(false);

  useEffect(() => {
    const unsubscribe = activityManager.subscribe(setActivities);
    return unsubscribe;
  }, []);

  const visibleActivities = isExpanded ? activities : activities.slice(0, maxItems);
  const hasMore = activities.length > maxItems;

  const getIcon = (type: ActivityItem['type']) => {
    switch (type) {
      case 'error':
        return <AlertCircle className="h-4 w-4 text-red-500" />;
      case 'success':
        return <CheckCircle className="h-4 w-4 text-green-500" />;
      case 'loading':
        return <Loader2 className="h-4 w-4 text-blue-500 animate-spin" />;
      default:
        return <Info className="h-4 w-4 text-gray-500" />;
    }
  };

  const getBackgroundColor = (type: ActivityItem['type']) => {
    switch (type) {
      case 'error':
        return 'bg-red-900/20 border-red-800';
      case 'success':
        return 'bg-green-900/20 border-green-800';
      case 'loading':
        return 'bg-blue-900/20 border-blue-800';
      default:
        return 'bg-gray-800 border-gray-700';
    }
  };

  if (activities.length === 0) {
    return null;
  }

  return (
    <div className="fixed top-4 right-4 z-50 w-96 space-y-2">
      {visibleActivities.map((activity) => (
        <div
          key={activity.id}
          className={`rounded-lg border p-3 shadow-sm transition-all duration-300 ${getBackgroundColor(activity.type)}`}
        >
          <div className="flex items-start gap-3">
            <div className="flex-shrink-0 mt-0.5">{getIcon(activity.type)}</div>
            <div className="flex-1 min-w-0">
              <p className="text-sm font-medium text-gray-100">{activity.message}</p>
              {activity.details && (
                <p className="mt-1 text-xs text-gray-400 break-words">{activity.details}</p>
              )}
              <p className="mt-1 text-xs text-gray-500">
                {activity.timestamp.toLocaleTimeString()}
              </p>
            </div>
            <button
              onClick={() => activityManager.removeActivity(activity.id)}
              className="flex-shrink-0 p-1 hover:bg-gray-700 hover:bg-opacity-50 rounded transition-colors"
            >
              <X className="h-3 w-3 text-gray-400" />
            </button>
          </div>
        </div>
      ))}
      
      {hasMore && (
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="w-full text-center py-2 text-xs text-gray-400 hover:text-gray-300 transition-colors"
        >
          {isExpanded ? 'Show less' : `Show ${activities.length - maxItems} more`}
        </button>
      )}
      
      {activities.length > 1 && (
        <button
          onClick={() => activityManager.clearAll()}
          className="w-full text-center py-1 text-xs text-gray-400 hover:text-gray-300 transition-colors"
        >
          Clear all
        </button>
      )}
    </div>
  );
}
</file>

<file path="components/BatchActionMenu.tsx">
'use client';

import React, { useState, useRef, useEffect } from 'react';

export interface BatchActionMenuProps {
  triggerButtonLabel: string;
  triggerButtonIcon: React.ReactNode;
  menuTitle: string;
  countInputState: [string, (value: string) => void];
  onCustomCountAction: (count: number) => void;
  customCountActionLabel: (count: string) => string;
  onAllEligibleAction?: () => void;
  allEligibleActionLabel?: string;
  getEligibleCount?: () => number;
  className?: string;
}

export function BatchActionMenu({
  triggerButtonLabel,
  triggerButtonIcon,
  menuTitle,
  countInputState,
  onCustomCountAction,
  customCountActionLabel,
  onAllEligibleAction,
  allEligibleActionLabel,
  getEligibleCount,
  className = ''
}: BatchActionMenuProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [customCount, setCustomCount] = countInputState;
  const menuRef = useRef<HTMLDivElement>(null);

  // Handle click outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);

  const handleCustomAction = () => {
    const count = parseInt(customCount, 10);
    if (count > 0) {
      onCustomCountAction(count);
      setIsOpen(false);
    }
  };

  const handleAllEligibleAction = () => {
    if (onAllEligibleAction) {
      onAllEligibleAction();
      setIsOpen(false);
    }
  };

  return (
    <div className={`relative ${className}`} ref={menuRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="btn-primary flex items-center gap-2"
      >
        {triggerButtonIcon}
        {triggerButtonLabel}
      </button>
      
      {isOpen && (
        <div className="absolute right-0 mt-2 w-64 bg-gray-900 border border-gray-700 rounded-lg shadow-lg z-10">
          <div className="p-2">
            <div className="mb-2">
              <div className="text-xs text-gray-400 mb-1">{menuTitle}</div>
              <input
                type="number"
                value={customCount}
                onChange={(e) => setCustomCount(e.target.value)}
                placeholder="Number of items"
                className="input-field w-full text-sm px-3 py-2"
                min="1"
                aria-label={menuTitle}
              />
              <button
                onClick={handleCustomAction}
                disabled={!customCount || parseInt(customCount, 10) <= 0}
                className="w-full text-left px-3 py-2 text-sm hover:bg-gray-800 rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed mt-1"
              >
                {customCountActionLabel(customCount)}
              </button>
            </div>
            
            {onAllEligibleAction && allEligibleActionLabel && (
              <>
                <div className="border-t border-gray-700 my-2"></div>
                <button
                  onClick={handleAllEligibleAction}
                  className="w-full text-left px-3 py-2 text-sm hover:bg-gray-800 rounded transition-colors"
                >
                  {allEligibleActionLabel}
                  {getEligibleCount && (
                    <span> ({getEligibleCount()})</span>
                  )}
                </button>
              </>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/DemoButton.tsx">
'use client';

import { activityManager } from './ActivityLog';

export default function DemoButton() {
  const runDemo = () => {
    // Simulate various activities
    activityManager.addActivity('info', 'Starting demo sequence...');
    
    setTimeout(() => {
      activityManager.addActivity('loading', 'Generating prompt for "genius"');
    }, 500);
    
    setTimeout(() => {
      activityManager.addActivity('success', 'Generated prompt for "genius"');
    }, 2000);
    
    setTimeout(() => {
      activityManager.addActivity('loading', 'Queuing image generation for "genius"');
    }, 2500);
    
    setTimeout(() => {
      activityManager.addActivity('error', 'Failed to generate image', 'Invalid API key. Please check your REPLICATE_API_TOKEN in .env.local');
    }, 4000);
  };

  return (
    <button
      onClick={runDemo}
      className="btn-secondary"
    >
      Demo Activity Log
    </button>
  );
}
</file>

<file path="data/gallery.json">
{
  "images": [
    {
      "id": 7876,
      "filename": "7876.png",
      "path": "/images/7876.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7877,
      "filename": "7877.png",
      "path": "/images/7877.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7878,
      "filename": "7878.png",
      "path": "/images/7878.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7879,
      "filename": "7879.png",
      "path": "/images/7879.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7880,
      "filename": "7880.png",
      "path": "/images/7880.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7881,
      "filename": "7881.png",
      "path": "/images/7881.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7882,
      "filename": "7882.png",
      "path": "/images/7882.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7883,
      "filename": "7883.png",
      "path": "/images/7883.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7884,
      "filename": "7884.png",
      "path": "/images/7884.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7885,
      "filename": "7885.png",
      "path": "/images/7885.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7886,
      "filename": "7886.png",
      "path": "/images/7886.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7887,
      "filename": "7887.png",
      "path": "/images/7887.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7888,
      "filename": "7888.png",
      "path": "/images/7888.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7889,
      "filename": "7889.png",
      "path": "/images/7889.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7890,
      "filename": "7890.png",
      "path": "/images/7890.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7891,
      "filename": "7891.png",
      "path": "/images/7891.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7892,
      "filename": "7892.png",
      "path": "/images/7892.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7893,
      "filename": "7893.png",
      "path": "/images/7893.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7894,
      "filename": "7894.png",
      "path": "/images/7894.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7895,
      "filename": "7895.png",
      "path": "/images/7895.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7896,
      "filename": "7896.png",
      "path": "/images/7896.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7897,
      "filename": "7897.png",
      "path": "/images/7897.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7898,
      "filename": "7898.png",
      "path": "/images/7898.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7899,
      "filename": "7899.png",
      "path": "/images/7899.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7900,
      "filename": "7900.png",
      "path": "/images/7900.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7901,
      "filename": "7901.png",
      "path": "/images/7901.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7902,
      "filename": "7902.png",
      "path": "/images/7902.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7903,
      "filename": "7903.png",
      "path": "/images/7903.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7904,
      "filename": "7904.png",
      "path": "/images/7904.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    },
    {
      "id": 7905,
      "filename": "7905.png",
      "path": "/images/7905.png",
      "word": null,
      "translation": null,
      "prompt": null,
      "created_at": "2025-05-28T13:26:12.269Z"
    }
  ],
  "metadata": {
    "total_count": 30,
    "last_updated": "2025-05-28T13:26:12.269Z",
    "version": "1.0"
  }
}
</file>

<file path="lib/db/runMigrations.ts">
import { getDatabase } from './database';
import { sql } from 'kysely';
import { up as addCategorizationMigration } from './migrations/002_add_categorization';

export async function runMigrations() {
  const db = getDatabase();
  
  try {
    // Check if categorization columns exist
    const columns = await sql<{ name: string }>`
      PRAGMA table_info(word_entries)
    `.execute(db);
    
    const hasCategorizationColumns = columns.rows.some(
      col => col.name.startsWith('categorization_')
    );
    
    if (!hasCategorizationColumns) {
      console.log('Running categorization migration...');
      await addCategorizationMigration(db);
      console.log('Categorization migration completed.');
    }
  } catch (error) {
    console.error('Migration error:', error);
    throw error;
  }
}
</file>

<file path="lib/paths.ts">
import path from 'path';

// Base directories
export const CWD = process.cwd();
export const DATA_DIR = path.join(CWD, 'data');
export const PUBLIC_DIR = path.join(CWD, 'public');

// Common file paths
export const GALLERY_JSON_PATH = path.join(DATA_DIR, 'gallery.json');
export const IMAGES_DIR_PATH = path.join(PUBLIC_DIR, 'images');
export const PROMPT_OVERRIDES_YAML_PATH = path.join(CWD, 'prompt_overrides.yaml');
export const DATABASE_FILE_PATH = path.join(DATA_DIR, 'language-cards.db');
</file>

<file path="lib/supabaseAdmin.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});
</file>

<file path="lib/supabaseImageStorage.ts">
import { supabaseAdmin } from './supabaseAdmin';
import { Buffer } from 'buffer';

export interface SupabaseImageUploadResult {
  imageUrl: string;
  originalUrl: string;
  filename: string;
  localPath?: string; // For compatibility with existing interfaces
}

/**
 * Upload an image buffer to Supabase Storage
 */
export async function uploadImageToSupabase(
  imageBuffer: Buffer,
  entryId: number,
  contentType: string = 'image/png'
): Promise<SupabaseImageUploadResult> {
  const filename = `${entryId}.png`;
  const filePath = `images/${filename}`;
  
  console.log(`Uploading image to Supabase: ${filePath}`);
  
  try {
    // Upload to Supabase Storage bucket
    const { data, error } = await supabaseAdmin.storage
      .from('emoji-images')
      .upload(filePath, imageBuffer, {
        contentType,
        upsert: true, // Allow overwriting for regeneration
      });

    if (error) {
      console.error('Supabase upload error:', error);
      throw new Error(`Failed to upload to Supabase: ${error.message}`);
    }

    console.log('Upload successful:', data);

    // Get public URL
    const { data: urlData } = supabaseAdmin.storage
      .from('emoji-images')
      .getPublicUrl(filePath);

    const publicUrl = urlData.publicUrl;
    console.log('Public URL:', publicUrl);

    return {
      imageUrl: publicUrl,
      originalUrl: publicUrl, // For compatibility
      filename,
      localPath: filePath, // Virtual path for compatibility
    };
  } catch (error) {
    console.error('Error uploading to Supabase:', error);
    throw error;
  }
}

/**
 * Download image from URL and upload to Supabase Storage
 */
export async function downloadAndUploadToSupabase(
  imageUrl: string,
  entryId: number
): Promise<SupabaseImageUploadResult> {
  console.log('Downloading and uploading image from:', imageUrl);
  
  // Fetch the image
  const response = await fetch(imageUrl);
  if (!response.ok) {
    throw new Error(`Failed to fetch image: ${response.statusText}`);
  }
  
  const imageBuffer = await response.arrayBuffer();
  const buffer = Buffer.from(imageBuffer);
  
  // Upload to Supabase
  return uploadImageToSupabase(buffer, entryId, 'image/png');
}

/**
 * Create the emoji-images bucket if it doesn't exist
 */
export async function ensureEmojiImagesBucket(): Promise<void> {
  console.log('Ensuring emoji-images bucket exists...');
  
  try {
    // Try to get bucket info first
    const { data: buckets, error: listError } = await supabaseAdmin.storage.listBuckets();
    
    if (listError) {
      console.error('Error listing buckets:', listError);
      throw listError;
    }
    
    const bucketExists = buckets?.some(bucket => bucket.name === 'emoji-images');
    
    if (!bucketExists) {
      console.log('Creating emoji-images bucket...');
      
      const { data, error } = await supabaseAdmin.storage.createBucket('emoji-images', {
        public: true,
        allowedMimeTypes: ['image/png', 'image/jpeg'],
        fileSizeLimit: '5MB'
      });
      
      if (error) {
        console.error('Error creating bucket:', error);
        throw new Error(`Failed to create bucket: ${error.message}`);
      }
      
      console.log('Bucket created successfully:', data);
    } else {
      console.log('Bucket already exists');
    }
  } catch (error) {
    console.error('Error ensuring bucket exists:', error);
    throw error;
  }
}
</file>

<file path="lib/vercelBlobUpload.ts">
import { put } from '@vercel/blob';
import { Buffer } from 'buffer';

// Option 1: If you can get a File object (e.g., from FormData)
export async function uploadFileToBlob(fileName: string, fileContent: File): Promise<string> {
  const blob = await put(fileName, fileContent, {
    access: 'public',
  });
  return blob.url;
}

// Option 2: If you have a Buffer (e.g., after fetching from Replicate)
export async function uploadBufferToBlob(fileName: string, fileBuffer: Buffer, contentType: string): Promise<string> {
  const blob = await put(fileName, fileBuffer, {
    access: 'public',
    contentType: contentType, // e.g., 'image/png'
  });
  return blob.url;
}
</file>

<file path="scripts/export-good-images.js">
#!/usr/bin/env node

const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const path = require('path');
const https = require('https');
const http = require('http');
require('dotenv').config({ path: path.join(__dirname, '..', '.env.local') });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('‚ùå Missing Supabase environment variables');
  console.error('Make sure NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are set in .env.local');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

const OUTPUT_DIR = path.join(__dirname, '..', 'good-images-export');
const IMAGES_DIR = path.join(OUTPUT_DIR, 'images');

function createDirectories() {
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }
  if (!fs.existsSync(IMAGES_DIR)) {
    fs.mkdirSync(IMAGES_DIR, { recursive: true });
  }
}

function downloadImage(url, filepath) {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https:') ? https : http;
    
    const request = client.get(url, (response) => {
      if (response.statusCode === 200) {
        const fileStream = fs.createWriteStream(filepath);
        response.pipe(fileStream);
        
        fileStream.on('finish', () => {
          fileStream.close();
          resolve();
        });
        
        fileStream.on('error', (err) => {
          fs.unlink(filepath, () => {}); // Delete the file on error
          reject(err);
        });
      } else {
        reject(new Error(`Failed to download image. Status code: ${response.statusCode}`));
      }
    });
    
    request.on('error', (err) => {
      reject(err);
    });
    
    request.setTimeout(30000, () => {
      request.abort();
      reject(new Error('Download timeout'));
    });
  });
}


async function downloadWithConcurrency(downloadTasks, concurrency = 5) {
  const results = [];
  let index = 0;
  
  async function downloadNext() {
    if (index >= downloadTasks.length) return;
    
    const currentIndex = index++;
    const task = downloadTasks[currentIndex];
    
    try {
      await downloadImage(task.url, task.filepath);
      console.log(`‚úÖ Downloaded ${currentIndex + 1}/${downloadTasks.length}: ${task.filename}`);
      results.push({ success: true, task });
    } catch (error) {
      console.error(`‚ùå Failed ${currentIndex + 1}/${downloadTasks.length}: ${task.filename} - ${error.message}`);
      results.push({ success: false, task, error });
    }
    
    // Download next task
    await downloadNext();
  }
  
  // Start concurrent downloads
  const workers = Array(Math.min(concurrency, downloadTasks.length))
    .fill()
    .map(() => downloadNext());
  
  await Promise.all(workers);
  return results;
}

async function main() {
  console.log('üöÄ Starting export of good images...');
  
  // Create output directories
  createDirectories();
  console.log(`üìÅ Created output directory: ${OUTPUT_DIR}`);
  
  // Query database for good images
  console.log('üîç Querying database for good images...');
  const { data: entries, error } = await supabase
    .from('word_entries')
    .select('id, original_text, translation_text, image_url')
    .eq('qa_score', 'good')
    .not('image_url', 'is', null);
  
  if (error) {
    console.error('‚ùå Database query failed:', error);
    process.exit(1);
  }
  
  if (!entries || entries.length === 0) {
    console.log('‚ÑπÔ∏è No good images found in database');
    return;
  }
  
  console.log(`üìä Found ${entries.length} good images to export`);
  
  // Prepare download tasks
  const downloadTasks = entries.map((entry) => {
    const filename = `${entry.id}.png`;
    const filepath = path.join(IMAGES_DIR, filename);
    
    return {
      id: entry.id,
      url: entry.image_url,
      filename,
      filepath,
      original: entry.original_text,
      translation: entry.translation_text
    };
  });
  
  // Start downloads
  console.log('‚¨áÔ∏è Starting downloads (5 concurrent)...');
  const results = await downloadWithConcurrency(downloadTasks, 5);
  
  // Summary
  const successful = results.filter(r => r.success).length;
  const failed = results.filter(r => !r.success).length;
  
  console.log('\nüìà Export Summary:');
  console.log(`‚úÖ Successful: ${successful}`);
  console.log(`‚ùå Failed: ${failed}`);
  console.log(`üìÅ Images saved to: ${IMAGES_DIR}`);
  
  if (failed > 0) {
    console.log('\n‚ùå Failed downloads:');
    results
      .filter(r => !r.success)
      .forEach(r => console.log(`   ${r.task.filename}: ${r.error.message}`));
  }
  
  console.log('\nüéâ Export completed!');
}

main().catch((error) => {
  console.error('üí• Unexpected error:', error);
  process.exit(1);
});
</file>

<file path="supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="utils/migrate-to-sqlite.ts">
#!/usr/bin/env node

/**
 * Migration utility to transfer data from localStorage to SQLite database
 * Run this script to migrate existing data: npx tsx utils/migrate-to-sqlite.ts
 */

import { languageCardRepository } from '../lib/db/repository';
import { WordEntry } from '../types';
import fs from 'fs';
import path from 'path';

// Mock localStorage for Node.js environment
const STORAGE_FILE = path.join(process.cwd(), '.localStorage-backup.json');

interface LocalStorageData {
  state: {
    entries: WordEntry[];
  };
}

async function loadFromLocalStorage(): Promise<WordEntry[]> {
  console.log('üîç Looking for localStorage data...');
  
  // In a real browser environment, this would read from actual localStorage
  // For the migration script, we'll need to export the data first
  console.log(`
To migrate your data:

1. Open your application in the browser
2. Open the browser console (F12)
3. Run this command to export your data:

const data = localStorage.getItem('language-card-storage');
if (data) {
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'language-cards-export.json';
  a.click();
  URL.revokeObjectURL(url);
  console.log('Data exported! Check your downloads folder.');
} else {
  console.log('No data found in localStorage');
}

4. Place the downloaded 'language-cards-export.json' file in the project root
5. Run this migration script again
  `);
  
  // Check if export file exists
  const exportFile = path.join(process.cwd(), 'language-cards-export.json');
  if (fs.existsSync(exportFile)) {
    console.log('‚úÖ Found export file: language-cards-export.json');
    const data = JSON.parse(fs.readFileSync(exportFile, 'utf-8'));
    
    // Parse the localStorage format
    const parsedData: LocalStorageData = JSON.parse(data);
    
    if (parsedData.state && Array.isArray(parsedData.state.entries)) {
      return parsedData.state.entries;
    }
  }
  
  return [];
}

async function migrateToSQLite() {
  try {
    console.log('üöÄ Starting migration from localStorage to SQLite...\n');
    
    // Load data from localStorage export
    const entries = await loadFromLocalStorage();
    
    if (entries.length === 0) {
      console.log('‚ùå No data found to migrate.');
      return;
    }
    
    console.log(`üìä Found ${entries.length} entries to migrate\n`);
    
    // Check if database already has data
    const existingEntries = await languageCardRepository.findAll();
    if (existingEntries.length > 0) {
      console.log(`‚ö†Ô∏è  Database already contains ${existingEntries.length} entries.`);
      console.log('Do you want to continue? This will merge the data.');
      // In a real scenario, you'd want to prompt for confirmation
    }
    
    // Migrate entries in batches
    const BATCH_SIZE = 100;
    let migrated = 0;
    
    for (let i = 0; i < entries.length; i += BATCH_SIZE) {
      const batch = entries.slice(i, i + BATCH_SIZE);
      
      try {
        await languageCardRepository.bulkUpsert(batch);
        migrated += batch.length;
        
        const progress = Math.round((migrated / entries.length) * 100);
        console.log(`Progress: ${progress}% (${migrated}/${entries.length} entries)`);
      } catch (error) {
        console.error(`‚ùå Error migrating batch ${i / BATCH_SIZE + 1}:`, error);
      }
    }
    
    console.log(`\n‚úÖ Migration completed! ${migrated} entries migrated to SQLite.`);
    
    // Verify migration
    const dbEntries = await languageCardRepository.findAll();
    console.log(`üìä Database now contains ${dbEntries.length} total entries.`);
    
    // Create backup of localStorage data
    const backupFile = path.join(process.cwd(), `localStorage-backup-${Date.now()}.json`);
    fs.writeFileSync(backupFile, JSON.stringify({ entries }, null, 2));
    console.log(`üíæ Backup saved to: ${backupFile}`);
    
    console.log('\nüéâ Migration successful! You can now use the application with SQLite database.');
    console.log('The localStorage data will remain as fallback until you clear it manually.');
    
  } catch (error) {
    console.error('‚ùå Migration failed:', error);
    process.exit(1);
  }
}

// Run migration
migrateToSQLite().catch(console.error);
</file>

<file path=".eslintrc.json">
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}
</file>

<file path="prompt_overrides.yaml">
# Quick Fixes for Directional Words - Using original_text as key
# These overrides replace abstract arrows with clearer person-based actions

# Basic directional words
above: "person pointing up"
below: "person pointing down"
left: "person pointing left"
right: "person pointing right"
up: "person looking up"
down: "person looking down"

# Positional relationships
between: "person between objects"
behind: "person stands behind object"
before: "person stands before object"
next: "person gestures next"
beside: "person stands beside object"

# Movement directions
forward: "person walking forward"
backward: "person walking backward"
through: "person walking through"
across: "person walking across"

# Additional problematic directional terms
under: "person pointing under"
over: "person pointing over"
inside: "person pointing inside"
outside: "person pointing outside"
around: "person walking around"
towards: "person walking towards"
away: "person walking away"
</file>

<file path="RANDOM_WORD_API_OPTIMIZATION.md">
# Random Word API Optimization Analysis

## Current Problem

The current implementation fetches **ALL** pending words from the database just to select a single random record. This is a critical performance anti-pattern.

### Why This Is Bad

1. **Performance Degradation**: O(n) time complexity where n = total pending records
   - 1,000 records = ~50ms query + ~10ms transfer
   - 10,000 records = ~500ms query + ~100ms transfer  
   - 100,000 records = ~5s query + ~1s transfer

2. **Memory Explosion**: Each record consumes memory
   - 1,000 records ‚âà 100KB in memory
   - 100,000 records ‚âà 10MB in memory
   - Risk of OOM errors in serverless environments

3. **Network Overhead**: Transferring unnecessary data
   - Bandwidth costs on cloud platforms
   - Slower response times for end users
   - Increased latency for international users

4. **Database Load**: Unnecessary full table scans
   - Locks more rows than needed
   - Increases database CPU usage
   - Affects other concurrent queries

5. **Cost Implications**:
   - Vercel/Supabase charge for data transfer
   - Higher compute time = higher serverless costs
   - Wasted resources = wasted money

## 5 Better Design Options

### Option 1: Native SQL Random Function
**Implementation**: Use Supabase's SQL function with proper random selection
```sql
CREATE OR REPLACE FUNCTION get_random_pending_word()
RETURNS TABLE(id INTEGER, prompt TEXT) AS $$
BEGIN
  RETURN QUERY
  SELECT w.id, w.prompt 
  FROM word_entries w
  WHERE w.image_status != 'completed'
  ORDER BY RANDOM()
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;
```

**Pros**:
- Single database round-trip
- Optimized at database level
- Minimal data transfer

**Cons**:
- ORDER BY RANDOM() can be slow on very large tables
- Requires database migration

**Performance**: O(n log n) but handled by database

---

### Option 2: Count + Offset Strategy
**Implementation**: Get total count, generate random offset, fetch single row
```typescript
const { count } = await supabase
  .from('word_entries')
  .select('*', { count: 'exact', head: true })
  .neq('image_status', 'completed');

const randomOffset = Math.floor(Math.random() * count);

const { data } = await supabase
  .from('word_entries')
  .select('id, prompt')
  .neq('image_status', 'completed')
  .range(randomOffset, randomOffset)
  .single();
```

**Pros**:
- Only fetches one record
- Works with existing Supabase client
- No database changes needed

**Cons**:
- Two database queries
- Offset can be slow on large datasets
- Possible race condition if records deleted between queries

**Performance**: O(1) for count + O(n) for offset

---

### Option 3: Pre-calculated Random Pool
**Implementation**: Maintain a separate table with pre-shuffled IDs
```typescript
// Background job shuffles pending IDs periodically
CREATE TABLE random_word_pool (
  position SERIAL PRIMARY KEY,
  word_id INTEGER REFERENCES word_entries(id),
  created_at TIMESTAMP DEFAULT NOW()
);

// API just pops from the pool
const { data } = await supabase
  .from('random_word_pool')
  .select('word_id')
  .order('position')
  .limit(1)
  .single();
```

**Pros**:
- O(1) selection time
- Truly random distribution
- Can implement weighted randomness

**Cons**:
- Requires background job
- Additional table maintenance
- Complexity increase

**Performance**: O(1) constant time

---

### Option 4: Sampling with Row Number
**Implementation**: Use ROW_NUMBER() with modulo arithmetic
```sql
WITH pending_words AS (
  SELECT id, prompt,
    ROW_NUMBER() OVER (ORDER BY id) as rn,
    COUNT(*) OVER () as total_count
  FROM word_entries
  WHERE image_status != 'completed'
)
SELECT id, prompt 
FROM pending_words 
WHERE rn = 1 + (FLOOR(RANDOM() * total_count)::INT % total_count);
```

**Pros**:
- Single query
- Efficient for medium datasets
- Deterministic ordering

**Cons**:
- Still scans all rows (but only once)
- Complex SQL

**Performance**: O(n) but optimized

---

### Option 5: Redis Cache with Randomization
**Implementation**: Cache pending word IDs in Redis, use SRANDMEMBER
```typescript
// On word status change, update Redis set
await redis.sadd('pending_words', wordId);
await redis.srem('pending_words', completedWordId);

// Get random word
const randomId = await redis.srandmember('pending_words');
const { data } = await supabase
  .from('word_entries')
  .select('id, prompt')
  .eq('id', randomId)
  .single();
```

**Pros**:
- O(1) random selection
- Minimal database load
- Scales to millions of records
- Can add TTL for auto-refresh

**Cons**:
- Additional infrastructure (Redis)
- Cache invalidation complexity
- Potential consistency issues

**Performance**: O(1) for selection + O(1) for fetch

---

## Recommendation

For immediate improvement with minimal changes: **Option 2 (Count + Offset)**

For long-term scalability: **Option 5 (Redis)** or **Option 3 (Pre-calculated Pool)**

## Metrics to Monitor

1. API response time (p50, p95, p99)
2. Database query time
3. Memory usage per request
4. Data transfer per request
5. Cost per 1000 API calls

## Implementation Priority

1. Quick fix: Implement Option 2 (1 hour)
2. Measure baseline performance
3. If >1000 pending words, implement Option 5
4. If >10,000 pending words, implement Option 3
5. Monitor and iterate
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="vercel.json">
{
  "functions": {
    "app/api/**/*.ts": {
      "maxDuration": 60
    }
  }
}
</file>

<file path="app/globals.css">
@import "tailwindcss";

@theme {
  --color-notion-gray-50: #0A0A0A;
  --color-notion-gray-100: #171717;
  --color-notion-gray-200: #262626;
  --color-notion-gray-300: #404040;
  --color-notion-gray-400: #525252;
  --color-notion-gray-500: #737373;
  --color-notion-gray-600: #A3A3A3;
  --color-notion-gray-700: #D4D4D4;
  --color-notion-gray-800: #E5E5E5;
  --color-notion-gray-900: #F7F7F7;
  --color-notion-blue: #3B82F6;
  --color-notion-green: #10B981;
  --color-notion-red: #EF4444;
  
  --radius-notion: 3px;
  --shadow-notion: 0 1px 3px rgba(255,255,255,0.1);
  --shadow-notion-hover: 0 2px 8px rgba(255,255,255,0.15);
}

:root {
  --background: 0 0 0;
  --foreground: 255 255 255;
}

body {
  color: rgb(var(--foreground));
  background: rgb(var(--background));
  font-family: 'JetBrains Mono', 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Fira Mono', 'Droid Sans Mono', 'Courier New', monospace;
}

/* Custom utility classes */
.btn-primary {
  display: inline-flex;
  align-items: center;
  gap: 0.375rem;
  background-color: var(--color-notion-blue);
  color: white;
  padding: 0.375rem 0.75rem;
  border-radius: var(--radius-notion);
  font-size: 0.75rem;
  font-weight: 500;
  transition: all 0.2s;
  border: none;
  cursor: pointer;
  white-space: nowrap;
}

.btn-primary:hover:not(:disabled) {
  background-color: #0052A3;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0, 102, 204, 0.2);
}

.btn-primary:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: none;
}

.btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-secondary {
  display: inline-flex;
  align-items: center;
  gap: 0.375rem;
  background-color: var(--color-notion-gray-100);
  color: var(--color-notion-gray-800);
  padding: 0.375rem 0.75rem;
  border: 1px solid var(--color-notion-gray-200);
  border-radius: var(--radius-notion);
  font-size: 0.75rem;
  font-weight: 500;
  transition: all 0.2s;
  cursor: pointer;
  white-space: nowrap;
}

.btn-secondary:hover:not(:disabled) {
  background-color: var(--color-notion-gray-200);
  border-color: var(--color-notion-gray-300);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(255, 255, 255, 0.05);
}

.btn-secondary:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: none;
}

.btn-secondary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.input-field {
  width: 100%;
  height: 2.25rem;
  padding: 0 0.75rem;
  border: 1px solid var(--color-notion-gray-200);
  border-radius: var(--radius-notion);
  font-size: 0.875rem;
}

.input-field:focus {
  outline: none;
  border-color: var(--color-notion-blue);
  box-shadow: 0 0 0 1px var(--color-notion-blue);
}

.table-header {
  background-color: var(--color-notion-gray-50);
  color: var(--color-notion-gray-600);
  font-weight: 500;
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.table-row {
  border-bottom: 1px solid var(--color-notion-gray-100);
  transition: background-color 0.2s;
}

.table-row:hover {
  background-color: var(--color-notion-gray-50);
}

.card {
  background-color: var(--color-notion-gray-100);
  border-radius: 0.5rem;
  padding: 1rem;
  box-shadow: var(--shadow-notion);
  transition: box-shadow 0.2s;
  border: 1px solid var(--color-notion-gray-200);
}

.card:hover {
  box-shadow: var(--shadow-notion-hover);
  border-color: var(--color-notion-gray-300);
}

.tab-active {
  border-bottom: 2px solid var(--color-notion-blue);
  color: var(--color-notion-blue);
  font-weight: 500;
}

.tab-inactive {
  color: var(--color-notion-gray-500);
  transition: color 0.2s;
}

.tab-inactive:hover {
  color: var(--color-notion-gray-700);
}

.loading-spinner {
  animation: spin 1s linear infinite;
  height: 0.75rem;
  width: 0.75rem;
  border: 2px solid var(--color-notion-gray-700);
  border-top-color: var(--color-notion-blue);
  border-radius: 50%;
  display: inline-block;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Card flip animation */
.card-container {
  perspective: 1000px;
}

.card-flip {
  position: relative;
  width: 100%;
  height: 100%;
  transition: transform 0.5s;
  transform-style: preserve-3d;
  cursor: pointer;
}

.card-flip.flipped {
  transform: rotateY(180deg);
}

.card-face {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
}

.card-back {
  transform: rotateY(180deg);
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import { JetBrains_Mono } from "next/font/google";
import "./globals.css";
import { Toaster } from 'react-hot-toast';
import ActivityLog from '@/components/ActivityLog';

const jetbrainsMono = JetBrains_Mono({
  subsets: ["latin"],
  variable: "--font-jetbrains",
});

export const metadata: Metadata = {
  title: "Language Learning Card Generator",
  description: "Generate emoji-style images for language learning cards",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${jetbrainsMono.variable} font-mono antialiased`}>
        {children}
        <ActivityLog />
        <Toaster
          position="bottom-right"
          toastOptions={{
            style: {
              background: '#171717',
              color: '#E5E5E5',
              border: '1px solid #404040',
              borderRadius: '6px',
              fontSize: '14px',
            },
            success: {
              iconTheme: {
                primary: '#10B981',
                secondary: '#171717',
              },
            },
            error: {
              iconTheme: {
                primary: '#EF4444',
                secondary: '#171717',
              },
            },
          }}
        />
      </body>
    </html>
  );
}
</file>

<file path="components/ASCIILogo.tsx">
export default function ASCIILogo() {
  return (
    <pre className="text-[8px] sm:text-[10px] md:text-xs leading-[0.8] text-gray-500 select-none font-mono">
{
`
$$\\                                                                                 
\\__|                                                                                
$$\\ $$$$$$\\$$$$\\   $$$$$$\\   $$$$$$\\   $$$$$$\\         $$$$$$\\   $$$$$$\\  $$$$$$$\\  
$$ |$$  _$$  _$$\\  \\____$$\\ $$  __$$\\ $$  __$$\\       $$  __$$\\ $$  __$$\\ $$  __$$\\ 
$$ |$$ / $$ / $$ | $$$$$$$ |$$ /  $$ |$$$$$$$$ |      $$ /  $$ |$$$$$$$$ |$$ |  $$ |
$$ |$$ | $$ | $$ |$$  __$$ |$$ |  $$ |$$   ____|      $$ |  $$ |$$   ____|$$ |  $$ |
$$ |$$ | $$ | $$ |\\$$$$$$$ |\\$$$$$$$ |\\$$$$$$$\\       \\$$$$$$$ |\\$$$$$$$\\ $$ |  $$ |
\\__|\\__| \\__| \\__| \\_______| \\____$$ | \\_______|       \\____$$ | \\_______|\\__|  \\__|
                            $$\\   $$ |                $$\\   $$ |                    
                            \\$$$$$$  |                \\$$$$$$  |                    
                             \\______/                  \\______/                     
`
    }</pre>
  );
}
</file>

<file path="lib/db/migrations/002_add_categorization.ts">
import { Kysely, sql } from 'kysely';
import { Database } from '../schema';

export async function up(db: Kysely<Database>) {
  // Add categorization columns to word_entries table
  await db.schema
    .alterTable('word_entries')
    .addColumn('categorization_primary_category', 'text', (col) =>
      col.check(sql`categorization_primary_category IN ('CONCRETE-VISUAL', 'ABSTRACT-SYMBOLIC', 'ACTION-VISUAL', 'STATE-METAPHORICAL') OR categorization_primary_category IS NULL`)
    )
    .addColumn('categorization_image_suitability', 'text', (col) =>
      col.check(sql`categorization_image_suitability IN ('HIGH', 'MEDIUM', 'LOW') OR categorization_image_suitability IS NULL`)
    )
    .addColumn('categorization_word_type', 'text', (col) =>
      col.check(sql`categorization_word_type IN ('noun', 'verb', 'adjective', 'adverb', 'phrase') OR categorization_word_type IS NULL`)
    )
    .addColumn('categorization_transformation_needed', 'integer') // SQLite boolean
    .addColumn('categorization_transformation_suggestion', 'text')
    .addColumn('categorization_confidence', 'real')
    .addColumn('categorization_status', 'text', (col) =>
      col.notNull().defaultTo('none')
        .check(sql`categorization_status IN ('none', 'processing', 'completed', 'error')`)
    )
    .execute();

  // Create index for categorization status
  await db.schema
    .createIndex('idx_word_entries_categorization_status')
    .on('word_entries')
    .column('categorization_status')
    .execute();
}

export async function down(db: Kysely<Database>) {
  // Drop the index
  await db.schema
    .dropIndex('idx_word_entries_categorization_status')
    .execute();

  // SQLite doesn't support dropping columns, would need to recreate table
  // For development, it's easier to just reset the database if needed
}
</file>

<file path="lib/db/migrations.ts">
import { Kysely, sql } from 'kysely';
import { Database } from './schema';

export async function createTables(db: Kysely<Database>) {
  // Check if tables already exist
  const tables = await sql<{ name: string }>`
    SELECT name FROM sqlite_master 
    WHERE type='table' AND name='word_entries'
  `.execute(db);
  
  if (tables.rows.length > 0) {
    return; // Tables already exist
  }
  
  // Create word_entries table
  await db.schema
    .createTable('word_entries')
    .addColumn('id', 'integer', (col) => col.primaryKey())
    .addColumn('original_text', 'text', (col) => col.notNull())
    .addColumn('translation_text', 'text', (col) => col.notNull())
    .addColumn('level_id', 'integer', (col) => col.notNull())
    .addColumn('transcription', 'text', (col) => col.notNull())
    .addColumn('prompt', 'text')
    .addColumn('image_url', 'text')
    .addColumn('image_status', 'text', (col) => 
      col.notNull().defaultTo('none')
        .check(sql`image_status IN ('none', 'queued', 'processing', 'completed', 'error')`)
    )
    .addColumn('prompt_status', 'text', (col) => 
      col.notNull().defaultTo('none')
        .check(sql`prompt_status IN ('none', 'generating', 'completed', 'error')`)
    )
    .addColumn('replicate_id', 'text')
    .addColumn('qa_score', 'text', (col) =>
      col.check(sql`qa_score IN ('good', 'bad') OR qa_score IS NULL`)
    )
    .addColumn('image_generated_at', 'text')
    .addColumn('created_at', 'text', (col) => 
      col.notNull().defaultTo(sql`CURRENT_TIMESTAMP`)
    )
    .addColumn('updated_at', 'text', (col) => 
      col.notNull().defaultTo(sql`CURRENT_TIMESTAMP`)
    )
    .execute();
  
  // Create indexes for performance
  await db.schema
    .createIndex('idx_word_entries_level_id')
    .on('word_entries')
    .column('level_id')
    .execute();
  
  await db.schema
    .createIndex('idx_word_entries_image_status')
    .on('word_entries')
    .column('image_status')
    .execute();
  
  await db.schema
    .createIndex('idx_word_entries_prompt_status')
    .on('word_entries')
    .column('prompt_status')
    .execute();
}
</file>

<file path="lib/db/schema.ts">
import { Kysely } from 'kysely';

export interface WordEntryTable {
  id: number;
  original_text: string;
  translation_text: string;
  level_id: number;
  transcription: string;
  prompt: string | null;
  image_url: string | null;
  image_status: 'none' | 'queued' | 'processing' | 'completed' | 'error';
  prompt_status: 'none' | 'generating' | 'completed' | 'error';
  replicate_id: string | null;
  qa_score: 'good' | 'bad' | null;
  image_generated_at: string | null;
  categorization_primary_category: 'CONCRETE-VISUAL' | 'ABSTRACT-SYMBOLIC' | 'ACTION-VISUAL' | 'STATE-METAPHORICAL' | null;
  categorization_image_suitability: 'HIGH' | 'MEDIUM' | 'LOW' | null;
  categorization_word_type: 'noun' | 'verb' | 'adjective' | 'adverb' | 'phrase' | null;
  categorization_transformation_needed: boolean | null;
  categorization_transformation_suggestion: string | null;
  categorization_confidence: number | null;
  categorization_status: 'none' | 'processing' | 'completed' | 'error';
  created_at: string;
  updated_at: string;
}

export interface Database {
  word_entries: WordEntryTable;
}

export type DB = Kysely<Database>;
</file>

<file path="lib/aiUtils.ts">
export interface AiErrorDetail {
  message: string;
  status: number;
}

export interface AiServiceErrorConfig {
  serviceName: string;
  apiKeyEnvVar: string;
  apiKeyErrorSubstrings: string[];
  rateLimitErrorSubstrings: string[];
  modelNotFoundErrorSubstrings: string[];
}

// Predefined configurations for common AI services
export const AI_SERVICE_CONFIGS = {
  gemini: {
    serviceName: 'Gemini',
    apiKeyEnvVar: 'GEMINI_API_KEY',
    apiKeyErrorSubstrings: ['API_KEY_INVALID', 'Invalid API key'],
    rateLimitErrorSubstrings: ['RATE_LIMIT_EXCEEDED', 'quota'],
    modelNotFoundErrorSubstrings: ['not found', '404']
  },
  openrouter: {
    serviceName: 'OpenRouter',
    apiKeyEnvVar: 'OPENROUTER_API_KEY',
    apiKeyErrorSubstrings: ['Invalid API key', 'Unauthorized'],
    rateLimitErrorSubstrings: ['Rate limit'],
    modelNotFoundErrorSubstrings: ['Model not found']
  }
} as const;

export function handleAiServiceError(
  error: unknown,
  config: AiServiceErrorConfig
): AiErrorDetail {
  console.error(`${config.serviceName} API Error:`, error);
  
  const errorMessage = error instanceof Error ? error.message : String(error);
  
  // Check for API key errors
  if (config.apiKeyErrorSubstrings.some(substring => errorMessage.includes(substring))) {
    return {
      message: `Invalid API key. Please check your ${config.apiKeyEnvVar} in .env.local`,
      status: 401
    };
  }
  
  // Check for rate limit errors
  if (config.rateLimitErrorSubstrings.some(substring => errorMessage.includes(substring))) {
    return {
      message: `Rate limit exceeded for ${config.serviceName}. Please try again later.`,
      status: 429
    };
  }
  
  // Check for model not found errors
  if (config.modelNotFoundErrorSubstrings.some(substring => errorMessage.includes(substring))) {
    return {
      message: `${config.serviceName} model not available. Please check the model configuration.`,
      status: 404
    };
  }
  
  // Default error
  return {
    message: errorMessage || `Failed to call ${config.serviceName} API.`,
    status: 500
  };
}
</file>

<file path="lib/promptOverrides.ts">
import * as yaml from 'js-yaml';
import * as fs from 'fs';
import { PROMPT_OVERRIDES_YAML_PATH } from './paths';

interface PromptOverrides {
  [key: string]: string;
}

let cachedOverrides: PromptOverrides | null = null;
let lastModified: number = 0;


function loadOverrides(): PromptOverrides {
  try {
    // Check if file exists
    if (!fs.existsSync(PROMPT_OVERRIDES_YAML_PATH)) {
      console.log('No prompt_overrides.yaml file found, using default behavior');
      return {};
    }

    // Check if we need to reload (file modified)
    const stats = fs.statSync(PROMPT_OVERRIDES_YAML_PATH);
    const currentModified = stats.mtime.getTime();

    if (cachedOverrides && currentModified === lastModified) {
      return cachedOverrides;
    }

    // Load and parse YAML file
    const fileContents = fs.readFileSync(PROMPT_OVERRIDES_YAML_PATH, 'utf8');
    const overrides = yaml.load(fileContents) as PromptOverrides;

    // Update cache
    cachedOverrides = overrides || {};
    lastModified = currentModified;

    console.log(`Loaded ${Object.keys(cachedOverrides).length} prompt overrides from YAML`);
    return cachedOverrides;

  } catch (error) {
    console.error('Error loading prompt overrides:', error);
    return {};
  }
}

export function getPromptOverride(word: string): string | null {
  const overrides = loadOverrides();
  const normalizedWord = word.toLowerCase().trim();
  
  return overrides[normalizedWord] || null;
}

export function hasPromptOverride(word: string): boolean {
  return getPromptOverride(word) !== null;
}
</file>

<file path="supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "sdxl-emoji-pipeline"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 5000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="plan.md">
# Simple One-Time Export Plan: Good Images

## Overview
Since this is a one-time export task, we should use the simplest possible approach:
**A single Node.js script that directly queries the database and downloads images.**

## Why This is Better
1. **No API needed** - Script connects directly to Supabase
2. **No UI integration** - Just run the script once
3. **No caching/rate limiting** - Not a production feature
4. **No complex architecture** - Keep it simple

## Single Script Approach

### File: `scripts/export-good-images.js`

**What it does:**
1. Connect directly to Supabase using the service role key
2. Query for all `qa_score = 'good'` entries with `image_url`
3. Download images to local folder with meaningful names

**Directory structure:**
```
good-images-export/
‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îú‚îÄ‚îÄ 001-apple-—è–±–ª–æ–∫–æ.png
‚îÇ   ‚îú‚îÄ‚îÄ 002-cat-–∫–æ—Ç.png
‚îÇ   ‚îî‚îÄ‚îÄ ...
```

**Dependencies:**
- `@supabase/supabase-js` (already in project)
- `node-fetch` for downloads
- Built-in `fs` and `path` modules

## Implementation Steps (2-3 hours total)

### Step 1: Create the script (1 hour)
- [ ] Create `scripts/export-good-images.js`
- [ ] Add Supabase connection using existing env vars
- [ ] Query database for good images
- [ ] Basic download logic

### Step 2: Add download features (1 hour)
- [ ] Parallel downloads (5 at a time)
- [ ] Progress logging to console
- [ ] Error handling for failed downloads

### Step 3: Test and run (30 min)
- [ ] Test with 10 images first
- [ ] Run full export
- [ ] Verify all images downloaded correctly

## Script Usage
```bash
cd scripts
node export-good-images.js
```

## What You Get
- All good images in `good-images-export/images/` folder
- Files named: `{id}.png`
- Console output showing progress

## No Additional Features Needed
- No resume capability (if it fails, just run again - it's fast)
- No zip creation (you can zip the folder manually if needed)
- No UI integration (one-time task)
- No rate limiting (direct DB access)
- No authentication (script runs locally with your keys)

## Why This is Much Better
1. **2-3 hours vs 12-14 hours** - 75% time savings
2. **Single file vs multiple files** - Much simpler
3. **No production code** - Won't affect the main app
4. **Direct and reliable** - No API layer to fail
5. **Perfect for one-time use** - Exactly what you need
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};
export default config;
</file>

<file path="app/api/random-pending-word/route.ts">
import { NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabaseAdmin';

// Cache for total word count
let cachedTotalCount: number | null = null;
let lastCountUpdate: number = 0;
const COUNT_CACHE_DURATION = 60 * 60 * 1000; // 1 hour in milliseconds

async function getTotalWordCount(): Promise<number> {
  const now = Date.now();
  
  // If cache is still valid, return cached value
  if (cachedTotalCount !== null && (now - lastCountUpdate) < COUNT_CACHE_DURATION) {
    return cachedTotalCount;
  }
  
  // Otherwise, fetch fresh count
  try {
    const { count, error } = await supabaseAdmin
      .from('word_entries')
      .select('*', { count: 'exact', head: true });
    
    if (error) {
      console.error('Error fetching total count:', error);
      // Fall back to previous cache or default
      return cachedTotalCount || 500;
    }
    
    // Update cache
    cachedTotalCount = count || 500;
    lastCountUpdate = now;
    console.log(`Updated total word count cache: ${cachedTotalCount}`);
    
    return cachedTotalCount;
  } catch (error) {
    console.error('Error in getTotalWordCount:', error);
    return cachedTotalCount || 500;
  }
}

export async function GET() {
  try {
    // Get total count (from cache or fresh)
    const totalCount = await getTotalWordCount();
    
    // Generate a random offset between 0 and totalCount - 1
    const randomOffset = Math.floor(Math.random() * totalCount);
    
    // Fetch a single word at the random offset
    // We get all fields to filter by status and get both texts
    const { data: words, error } = await supabaseAdmin
      .from('word_entries')
      .select('id, prompt, original_text, translation_text, image_status')
      .range(randomOffset, randomOffset + 10); // Get a few extra in case some are completed
    
    if (error) {
      console.error('Database error:', error);
      return NextResponse.json(
        { success: false, error: 'Failed to fetch word' },
        { status: 500 }
      );
    }
    
    // Find the first word that isn't completed
    const pendingWord = words?.find(word => word.image_status !== 'completed');
    
    if (!pendingWord) {
      // If no pending word found in this range, try a different approach
      // This is a fallback - fetch specifically pending words with limit
      const { data: fallbackWords, error: fallbackError } = await supabaseAdmin
        .from('word_entries')
        .select('id, prompt, original_text, translation_text')
        .neq('image_status', 'completed')
        .limit(1);
      
      if (fallbackError || !fallbackWords || fallbackWords.length === 0) {
        return NextResponse.json(
          { success: false, error: 'No pending words found' },
          { status: 404 }
        );
      }
      
      const word = fallbackWords[0];
      return NextResponse.json({
        id: word.id,
        prompt: word.prompt,
        original_text: word.original_text,
        translation_text: word.translation_text
      });
    }
    
    // Return id, prompt, and both text fields
    return NextResponse.json({
      id: pendingWord.id,
      prompt: pendingWord.prompt,
      original_text: pendingWord.original_text,
      translation_text: pendingWord.translation_text
    });
    
  } catch (error) {
    console.error('Error fetching random pending word:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}
</file>

<file path="components/QueueStatus.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Clock, CheckCircle, XCircle, Loader } from 'lucide-react';

interface QueueStatus {
  total: number;
  pending: number;
  processing: number;
  completed: number;
  errors: number;
  isProcessing: boolean;
}

export default function QueueStatus() {
  const [status, setStatus] = useState<QueueStatus | null>(null);
  const [isVisible, setIsVisible] = useState(false);

  const fetchStatus = async () => {
    try {
      const response = await fetch('/api/queue-image', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'status' }),
      });

      if (response.ok) {
        const data = await response.json();
        setStatus(data);
        setIsVisible(data.total > 0);
      }
    } catch (error) {
      console.error('Failed to fetch queue status:', error);
    }
  };

  useEffect(() => {
    // Initial fetch
    fetchStatus();

    // Poll every 2 seconds
    const interval = setInterval(fetchStatus, 2000);

    return () => clearInterval(interval);
  }, []);

  if (!isVisible || !status) {
    return null;
  }

  return (
    <div className="fixed bottom-4 right-4 bg-gray-900 border border-gray-700 rounded-lg p-4 shadow-lg min-w-64 z-50">
      <div className="flex items-center justify-between mb-3">
        <h3 className="text-sm font-medium text-gray-100">Image Queue</h3>
        <button
          onClick={() => setIsVisible(false)}
          className="text-gray-400 hover:text-gray-300"
        >
          √ó
        </button>
      </div>

      <div className="space-y-2">
        {status.pending > 0 && (
          <div className="flex items-center gap-2 text-xs">
            <Clock className="h-3 w-3 text-yellow-500" />
            <span className="text-gray-300">Pending: {status.pending}</span>
          </div>
        )}

        {status.processing > 0 && (
          <div className="flex items-center gap-2 text-xs">
            <Loader className="h-3 w-3 text-blue-500 animate-spin" />
            <span className="text-gray-300">Processing: {status.processing}</span>
          </div>
        )}

        {status.completed > 0 && (
          <div className="flex items-center gap-2 text-xs">
            <CheckCircle className="h-3 w-3 text-green-500" />
            <span className="text-gray-300">Completed: {status.completed}</span>
          </div>
        )}

        {status.errors > 0 && (
          <div className="flex items-center gap-2 text-xs">
            <XCircle className="h-3 w-3 text-red-500" />
            <span className="text-gray-300">Errors: {status.errors}</span>
          </div>
        )}

        <div className="pt-2 border-t border-gray-700">
          <div className="text-xs text-gray-400">
            Total: {status.total} {status.isProcessing ? '(Active)' : '(Idle)'}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="lib/apiUtils.ts">
import { NextRequest, NextResponse } from 'next/server';

type ApiHandler<T = any, U = any> = (request: NextRequest, body?: T) => Promise<NextResponse<U>>;

export interface ApiRequestOptions {
  parseBody?: boolean;
}

export async function handleApiRequest<T = any, U = any>(
  request: NextRequest,
  handler: ApiHandler<T, U>,
  options: ApiRequestOptions = { parseBody: true }
): Promise<NextResponse<U | { error: string }>> {
  try {
    let body: T | undefined;
    
    if ((request.method === 'POST' || request.method === 'PATCH' || request.method === 'PUT') && options.parseBody) {
      try {
        body = await request.json();
      } catch (e) {
        return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
      }
    }
    
    return await handler(request, body);
  } catch (error: any) {
    console.error(`API Error in ${request.url}:`, error);
    
    // If error is already a NextResponse, return it
    if (error instanceof Response) {
      return error as NextResponse;
    }
    
    // Extract status and message from error if available
    const status = error.status || 500;
    const message = error.message || 'Internal Server Error';
    
    // If error object has an explicit error field, use it
    if (error.error) {
      return NextResponse.json({ error: error.error }, { status });
    }
    
    return NextResponse.json({ error: message }, { status });
  }
}

// Validation utilities
export function validateRequestBody<T>(body: any, requiredFields: (keyof T)[]): { valid: boolean; error?: string; status?: number } {
  if (!body) {
    return { valid: false, error: 'Request body is missing.', status: 400 };
  }
  
  for (const field of requiredFields) {
    const value = body[field];
    if (value === undefined || value === null || (typeof value === 'string' && value.trim() === '')) {
      return { valid: false, error: `Missing required field: ${String(field)}`, status: 400 };
    }
  }
  
  return { valid: true };
}

export function validateRequestArray<T>(array: any, itemName: string = 'entries'): { valid: boolean; error?: string; status?: number } {
  if (!array || !Array.isArray(array)) {
    return { valid: false, error: `Missing or invalid "${itemName}" array.`, status: 400 };
  }
  
  if (array.length === 0) {
    return { valid: false, error: `"${itemName}" array cannot be empty.`, status: 400 };
  }
  
  return { valid: true };
}
</file>

<file path="lib/imageUtils.ts">
import fs from 'fs';
import path from 'path';
import { IMAGES_DIR_PATH } from './paths';
import { uploadImageToSupabase, ensureEmojiImagesBucket } from './supabaseImageStorage';

export interface ImageSaveOptions {
  resize?: {
    width: number;
    height: number;
    fit: 'cover' | 'contain' | 'fill' | 'inside' | 'outside';
    position?: string;
  };
  storage?: 'local' | 'supabase'; // Storage destination choice
}

export interface ImageSaveResult {
  localImageUrl: string;
  originalUrl: string;
  localPath: string;
  filename: string;
}

export async function saveImageFromUrl(
  imageUrl: string,
  entryId: number,
  options?: ImageSaveOptions
): Promise<ImageSaveResult> {
  console.log('Downloading image from:', imageUrl);
  
  // Fetch the image
  const response = await fetch(imageUrl);
  if (!response.ok) {
    throw new Error(`Failed to fetch image: ${response.statusText}`);
  }
  
  const imageBuffer = await response.arrayBuffer();
  let buffer = Buffer.from(imageBuffer);
  
  // Skip resizing for now to reduce deployment size
  if (options?.resize) {
    console.log(`Image resizing requested but disabled for deployment size optimization`);
  }
  
  const filename = `${entryId}.png`;
  
  // Choose storage destination
  if (options?.storage === 'supabase') {
    // Upload to Supabase Storage
    console.log('Uploading to Supabase Storage...');
    await ensureEmojiImagesBucket();
    
    const uploadResult = await uploadImageToSupabase(buffer, entryId, 'image/png');
    
    return {
      localImageUrl: uploadResult.imageUrl, // Supabase public URL
      originalUrl: imageUrl,
      localPath: uploadResult.localPath || `images/${filename}`,
      filename: uploadResult.filename
    };
  } else {
    // Default: Save to local filesystem
    if (!fs.existsSync(IMAGES_DIR_PATH)) {
      fs.mkdirSync(IMAGES_DIR_PATH, { recursive: true });
    }
    
    const filepath = path.join(IMAGES_DIR_PATH, filename);
    
    // Save the file
    fs.writeFileSync(filepath, buffer);
    console.log('Image saved to:', filepath);
    
    // Return both the original URL and the local path with cache-busting timestamp
    const timestamp = Date.now();
    const localImageUrl = `/images/${filename}?t=${timestamp}`;
    
    return {
      localImageUrl,
      originalUrl: imageUrl,
      localPath: filepath,
      filename
    };
  }
}
</file>

<file path="lib/openrouter.ts">
// Shared types and interfaces for OpenRouter
// This file can be imported by both client and server

export interface OpenRouterMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface BatchPromptEntry {
  id: number;
  english: string;
  russian: string;
  transcription: string;
}

// Re-export server-only functions for backward compatibility
// These will throw errors if imported client-side
export { 
  callOpenRouter,
  handleOpenRouterError,
  formatOpenRouterBatchPromptMessages,
  OPENROUTER_BASE_URL,
  OPENROUTER_MODEL,
  BATCH_PROMPT_GENERATION_INSTRUCTIONS
} from './openrouter.server';
</file>

<file path="lib/replicateConfig.ts">
// Centralized Replicate configuration - single source of truth
export const REPLICATE_CONFIG = {
  model: "fofr/sdxl-emoji:dee76b5afde21b0f01ed7925f0665b7e879c50ee718c5f78a9d38e04d523cc5e",
  
  // Image generation parameters
  input: {
    negative_prompt: "black skin, dark skin",
    width: 1152,
    height: 896,
    num_outputs: 1,
    num_inference_steps: 50,
    guidance_scale: 7.5,
    scheduler: "K_EULER" as const,
    lora_scale: 0.6,
    refine: "no_refiner" as const,
    apply_watermark: false,
    high_noise_frac: 0.8,
    prompt_strength: 0.8,
    disable_safety_checker: true,
  }
} as const;

// Function to create input with prompt
export function createReplicateInput(prompt: string) {
  return {
    ...REPLICATE_CONFIG.input,
    prompt: `A TOK emoji of ${prompt}`,
  };
}

// Function to get model identifier
export function getReplicateModel() {
  return REPLICATE_CONFIG.model;
}
</file>

<file path="app/api/gallery/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { handleApiRequest } from '@/lib/apiUtils';
import { GALLERY_JSON_PATH, IMAGES_DIR_PATH } from '@/lib/paths';
import { languageCardRepository } from '@/lib/db/repository';
import { WordEntry } from '@/types';

export async function GET(request: NextRequest) {
  return handleApiRequest(request, async () => {
    // Try to get images from database first (preferred for Supabase)
    const galleryData = await generateGalleryFromDatabase();

    // Fallback to local file scanning and JSON if needed
    if (galleryData.images.length === 0) {
      let fallbackData;
      if (fs.existsSync(GALLERY_JSON_PATH)) {
        const fileContent = fs.readFileSync(GALLERY_JSON_PATH, 'utf8');
        fallbackData = JSON.parse(fileContent);
      } else {
        fallbackData = await generateGalleryFromImages();
      }
      return NextResponse.json(fallbackData);
    }

    return NextResponse.json(galleryData);
  }, { parseBody: false });
}

async function generateGalleryFromDatabase() {
  try {
    // Get all entries from database and filter those with images
    const allEntries = await languageCardRepository.findAll();
    const entriesWithImages = allEntries.filter(entry => 
      entry.imageUrl && entry.imageStatus === 'completed'
    ); // Reasonable limit for gallery
    
    const images = entriesWithImages.map((entry: WordEntry) => ({
      id: entry.id,
      filename: `${entry.id}.png`,
      path: entry.imageUrl, // This will be either Supabase URL or local path
      word: entry.original_text,
      translation: entry.translation_text,
      prompt: entry.prompt,
      created_at: entry.imageGeneratedAt || entry.createdAt
    }));
    
    return {
      images,
      metadata: {
        total_count: images.length,
        last_updated: new Date().toISOString(),
        version: "2.0",
        source: "database"
      }
    };
  } catch (error) {
    console.error('Error generating gallery from database:', error);
    return {
      images: [],
      metadata: {
        total_count: 0,
        last_updated: new Date().toISOString(),
        version: "2.0",
        source: "database_error",
        error: error instanceof Error ? error.message : 'Unknown error'
      }
    };
  }
}

async function generateGalleryFromImages() {
  const imageFiles = fs.readdirSync(IMAGES_DIR_PATH)
    .filter(file => /\.(png|jpg|jpeg|webp)$/i.test(file))
    .map(filename => {
      const nameWithoutExt = path.parse(filename).name;
      // Only include files with numeric IDs
      if (isNaN(Number(nameWithoutExt))) {
        return null;
      }
      return {
        id: Number(nameWithoutExt),
        filename,
        path: `/images/${nameWithoutExt}.png`,
        word: null,
        translation: null,
        prompt: null,
        created_at: new Date().toISOString()
      };
    })
    .filter(Boolean); // Remove null entries

  const galleryData = {
    images: imageFiles,
    metadata: {
      total_count: imageFiles.length,
      last_updated: new Date().toISOString(),
      version: "1.0"
    }
  };

  // Note: On Vercel, we can't write to the filesystem, so we return the generated data
  // without saving it. For persistent storage, consider using your Supabase database.
  return galleryData;
}
</file>

<file path="app/api/generate-images-batch/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { imageQueue } from '@/lib/imageQueue';
import { handleApiRequest, validateRequestArray } from '@/lib/apiUtils';

interface GenerateImageBatchRequestEntry {
  entryId: number;
  prompt: string;
  englishWord: string;
}

export async function POST(request: NextRequest) {
  return handleApiRequest(request, async (_req, body: { entries: GenerateImageBatchRequestEntry[] }) => {
    // Input validation
    const validation = validateRequestArray(body.entries, 'entries');
    if (!validation.valid) {
      return NextResponse.json({ error: validation.error }, { status: validation.status });
    }

    const { entries } = body;

    // Initialize counters
    let successfullyQueuedCount = 0;
    let failedToQueueCount = 0;
    const itemErrors: Array<{ entryId: number; error: string }> = [];

    // Process each entry
    for (const entry of entries) {
      // Validate each item
      if (!entry.entryId || !entry.prompt || !entry.prompt.trim() || !entry.englishWord) {
        failedToQueueCount++;
        itemErrors.push({
          entryId: entry.entryId || -1,
          error: 'Missing entryId, prompt, or englishWord.'
        });
        console.warn(`Skipping invalid entry in batch image generation: ${JSON.stringify(entry)}`);
        continue;
      }

      try {
        await imageQueue.addToQueue(entry.entryId, entry.englishWord, entry.prompt);
        successfullyQueuedCount++;
      } catch (queueError) {
        console.error(`Error adding entry ${entry.entryId} to imageQueue:`, queueError);
        failedToQueueCount++;
        itemErrors.push({
          entryId: entry.entryId,
          error: queueError instanceof Error ? queueError.message : 'Failed to add to internal queue.'
        });
      }
    }

    // Prepare response
    let responseMessage: string;
    
    if (failedToQueueCount > 0 && successfullyQueuedCount === 0) {
      responseMessage = `Failed to queue all ${failedToQueueCount} images.`;
      return NextResponse.json(
        {
          success: false,
          message: responseMessage,
          queuedCount: successfullyQueuedCount,
          errorCount: failedToQueueCount,
          errors: itemErrors
        },
        { status: 500 }
      );
    }

    responseMessage = `Successfully queued ${successfullyQueuedCount} images for generation.`;
    if (failedToQueueCount > 0) {
      responseMessage += ` Failed to queue ${failedToQueueCount} images.`;
    }

    return NextResponse.json({
      success: true,
      message: responseMessage,
      queuedCount: successfullyQueuedCount,
      errorCount: failedToQueueCount,
      errors: itemErrors.length > 0 ? itemErrors : undefined
    });

  });
}
</file>

<file path="app/api/language-cards/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { languageCardRepository } from '@/lib/db/repository';
import { WordEntry } from '@/types';
import { handleApiRequest, validateRequestBody } from '@/lib/apiUtils';

export async function GET(request: NextRequest) {
  return handleApiRequest(request, async () => {
    const entries = await languageCardRepository.findAll();
    return NextResponse.json(entries);
  }, { parseBody: false });
}

export async function POST(request: NextRequest) {
  return handleApiRequest(request, async (_req, body: WordEntry[]) => {
    if (!Array.isArray(body)) {
      return NextResponse.json({ error: 'Request body must be an array of entries' }, { status: 400 });
    }
    
    await languageCardRepository.bulkUpsert(body);
    return NextResponse.json({ success: true });
  });
}

export async function PATCH(request: NextRequest) {
  return handleApiRequest(request, async (_req, body: { id: number; updates: Partial<WordEntry> }) => {
    const validation = validateRequestBody(body, ['id', 'updates']);
    if (!validation.valid) {
      return NextResponse.json({ error: validation.error }, { status: validation.status });
    }
    
    await languageCardRepository.update(body.id, body.updates);
    return NextResponse.json({ success: true });
  });
}
</file>

<file path="app/api/test-categorization/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getGeminiModel } from '@/lib/gemini';
import { handleApiRequest } from '@/lib/apiUtils';

export async function GET(request: NextRequest) {
  return handleApiRequest(request, async () => {
    const testWords = [
      { id: 1, original_text: 'a, an', translation_text: '–Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –∞—Ä—Ç–∏–∫–ª—å', level_id: 66 },
      { id: 2, original_text: 'about', translation_text: '–æ, –æ–∫–æ–ª–æ, –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ, –ø–æ—á—Ç–∏', level_id: 66 }
    ];
    
    const model = getGeminiModel();
    const results = [];
    
    for (const word of testWords) {
      const prompt = `Categorize "${word.original_text}" (${word.translation_text}) for emoji image generation.

Return JSON:
{
  "primary_category": "CONCRETE-VISUAL" or "ABSTRACT-SYMBOLIC" or "ACTION-VISUAL" or "STATE-METAPHORICAL",
  "image_suitability": "HIGH" or "MEDIUM" or "LOW",
  "word_type": "noun" or "verb" or "adjective" or "adverb" or "phrase",
  "transformation_needed": true or false,
  "transformation_suggestion": "",
  "confidence": 0.9
}`;

      try {
        console.log(`Testing categorization for "${word.original_text}"`);
        
        const response = await model.generateContent({
          contents: [{ role: 'user', parts: [{ text: prompt }] }],
          generationConfig: {
            temperature: 0.1,
            maxOutputTokens: 200,
            responseMimeType: 'application/json',
          },
          thinkingConfig: {
            includeThoughts: false,
          },
        });
        
        const result = response.response;
        const text = result.text().trim();
        
        console.log(`Response for "${word.original_text}":`, text);
        console.log('Usage metadata:', result.usageMetadata);
        
        results.push({
          word: word.original_text,
          success: true,
          response: text,
          usage: result.usageMetadata
        });
      } catch (error) {
        console.error(`Error for "${word.original_text}":`, error);
        results.push({
          word: word.original_text,
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }
    
    return NextResponse.json({ results });
  }, { parseBody: false });
}
</file>

<file path="app/api/test-gemini/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getGeminiModel } from '@/lib/gemini';
import { handleApiRequest } from '@/lib/apiUtils';

export async function GET(request: NextRequest) {
  return handleApiRequest(request, async () => {
    // Check if API key exists
    if (!process.env.GEMINI_API_KEY) {
      return NextResponse.json({ 
        error: 'GEMINI_API_KEY is not set in environment variables',
        status: 'error' 
      }, { status: 500 });
    }
    
    const model = getGeminiModel();
    
    // Simple test prompt
    const testPrompt = 'Return a simple JSON object: {"test": "success", "number": 42}';
    
    console.log('Testing Gemini API...');
    
    const response = await model.generateContent({
      contents: [{ role: 'user', parts: [{ text: testPrompt }] }],
      generationConfig: {
        temperature: 0.1,
        topK: 1,
        topP: 0.95,
        maxOutputTokens: 100,
      },
    });
    
    const result = response.response;
    const text = result.text().trim();
    
    console.log('Gemini test response:', text);
    
    return NextResponse.json({
      status: 'success',
      model: 'gemini-2.5-flash-preview-05-20',
      response: text,
      apiKeySet: true,
    });
  }, { parseBody: false });
}
</file>

<file path="components/FileUpload.tsx">
'use client';

import { useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { useAppStore } from '@/store/useAppStore';
import { JSONImportData, WordEntry } from '@/types';
import { Upload, AlertCircle } from 'lucide-react';
import toast from 'react-hot-toast';
import { activityManager } from './ActivityLog';

export default function FileUpload() {
  const { setEntries } = useAppStore();

  const processJSONFile = (data: JSONImportData[]): WordEntry[] => {
    return data.map((item) => ({
      ...item,
      prompt: '',
      imageUrl: '',
      imageStatus: 'none',
      promptStatus: 'none',
      replicateId: '',
    }));
  };

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    if (!file) return;

    const operationKey = `upload-${Date.now()}`;
    activityManager.addActivity('loading', `Processing ${file.name}...`, undefined, operationKey);

    try {
      const text = await file.text();
      const data = JSON.parse(text) as JSONImportData[];

      // Validate JSON structure
      if (!Array.isArray(data)) {
        throw new Error('JSON must be an array');
      }

      const requiredFields = ['id', 'original_text', 'translation_text', 'level_id', 'transcription'];
      const invalidItems = data.filter((item, index) => {
        const missingFields = requiredFields.filter(field => !(field in item));
        if (missingFields.length > 0) {
          console.error(`Item at index ${index} missing fields:`, missingFields);
          return true;
        }
        return false;
      });

      if (invalidItems.length > 0) {
        throw new Error(`${invalidItems.length} items have missing required fields`);
      }

      const entries = processJSONFile(data);
      setEntries(entries);
      
      const levels = [...new Set(entries.map(e => e.level_id))].length;
      activityManager.addActivity('success', `Loaded ${entries.length} entries`, `${levels} difficulty levels found`, operationKey);
    } catch (error) {
      console.error('Error processing file:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to process file';
      activityManager.addActivity('error', 'Failed to process file', errorMessage, operationKey);
    }
  }, [setEntries]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'application/json': ['.json']
    },
    maxFiles: 1
  });

  return (
    <div className="max-w-4xl mx-auto">
      <div className="bg-gray-900 rounded-lg p-8 shadow-sm border border-gray-800">
        <div
          {...getRootProps()}
          className={`
            border-2 border-dashed rounded-lg p-12 text-center cursor-pointer transition-colors
            ${isDragActive 
              ? 'border-blue-600 bg-blue-900/20' 
              : 'border-gray-700 hover:border-gray-600'
            }
          `}
        >
          <input {...getInputProps()} />
          <Upload className="mx-auto h-12 w-12 mb-4 text-gray-500" />
          
          {isDragActive ? (
            <p className="font-medium text-gray-300">Drop the JSON file here...</p>
          ) : (
            <>
              <p className="font-medium mb-2 text-gray-300">
                Drag and drop your JSON file here
              </p>
              <p className="text-sm text-gray-400">
                or click to select a file
              </p>
            </>
          )}
        </div>

        <div className="mt-6 p-4 rounded-lg bg-gray-800 border border-gray-700">
          <div className="flex items-start">
            <AlertCircle className="h-5 w-5 flex-shrink-0 mt-0.5 text-blue-600" />
            <div className="ml-3">
              <h3 className="text-sm font-medium text-gray-100">Expected JSON format</h3>
              <pre className="mt-2 text-xs overflow-x-auto text-gray-400">
{`[
  {
    "id": 11643,
    "original_text": "genius",
    "translation_text": "–≥–µ–Ω–∏–π",
    "level_id": 70,
    "transcription": "[Àà §iÀênj…ôs]"
  }
]`}
              </pre>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="lib/db/database.ts">
import { createPool } from '@vercel/postgres';
import { Kysely, PostgresDialect } from 'kysely';
import { Database as DatabaseType, DB } from './schema';
// Migration imports removed - will be handled externally for Vercel deployment

let db: DB | null = null;

export function getDatabase(): DB {
  if (!db) {
    if (!process.env.DATABASE_URL) {
      throw new Error('DATABASE_URL environment variable is not set');
    }
    
    const pool = createPool({
      connectionString: process.env.DATABASE_URL,
    });
    
    db = new Kysely<DatabaseType>({
      dialect: new PostgresDialect({
        pool,
      }),
    });
    
    // Note: For Vercel deployment, migrations should be run externally
    // using npx kysely migrate or similar command
  }
  
  return db;
}

export function closeDatabase(): void {
  if (db) {
    db.destroy();
    db = null;
  }
}
</file>

<file path="lib/gemini.ts">
import { GoogleGenerativeAI } from '@google/generative-ai';
import { handleAiServiceError, AI_SERVICE_CONFIGS } from './aiUtils';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

export const GEMINI_MODEL = 'gemini-2.5-flash-preview-05-20';

export const CORE_PROMPT_INSTRUCTIONS = `Generate ONE emoji object for: {english_word}

Rules:
1. Object MUST visually represent the word's meaning
2. Maximum 4 words
3. Single object only
4. Choose most memorable/iconic association
5. If describing people, use light-skinned or yellow emoji-style characters
6. FORBIDDEN: "vibrant", "representing", "showing", generic descriptions

Think: What visual helps remember this word?

Examples:
"autumn" ‚Üí "orange fall leaf" (NOT green leaf)
"winter" ‚Üí "snowflake" (NOT generic season)
"happy" ‚Üí "smiling face"
"article" ‚Üí "newspaper"
"above" ‚Üí "upward arrow"
"actor" ‚Üí "light-skinned man in suit"

Word: {english_word}
Single object:`;

export const PROMPT_TEMPLATE = `${CORE_PROMPT_INSTRUCTIONS}

English: {english} {transcription}
Russian: {russian}`;

export const BATCH_PROMPT_TEMPLATE = `For each word below, generate ONE emoji object following these rules:

1. Object MUST visually represent the word's meaning
2. Maximum 4 words
3. Single object only
4. Choose most memorable/iconic association
5. If describing people, use light-skinned or yellow emoji-style characters
6. FORBIDDEN: "vibrant", "representing", "showing", generic descriptions

Think: What visual helps remember this word?

Examples:
"autumn" ‚Üí "orange fall leaf" (NOT green leaf)
"winter" ‚Üí "snowflake" (NOT generic season)
"happy" ‚Üí "smiling face"
"article" ‚Üí "newspaper"
"above" ‚Üí "upward arrow"
"actor" ‚Üí "light-skinned man in suit"

Return your response as a JSON array where each object has an "id" field matching the input id and a "prompt" field with the single object description.

Word pairs:
{wordPairs}

Return valid JSON only, no markdown formatting.`;

export function getGeminiModel() {
  return genAI.getGenerativeModel({ 
    model: GEMINI_MODEL,
    systemInstruction: 'Output only valid JSON. No explanations.'
  });
}

export function formatSinglePrompt(english: string, russian: string, transcription: string): string {
  return PROMPT_TEMPLATE
    .replace('{english_word}', english)
    .replace('{english}', english)
    .replace('{transcription}', transcription)
    .replace('{russian}', russian);
}

export function formatBatchPrompt(entries: Array<{ id: number; english: string; russian: string; transcription: string }>): string {
  const wordPairs = entries.map(entry => 
    `ID: ${entry.id}\nEnglish: ${entry.english} ${entry.transcription}\nRussian: ${entry.russian}`
  ).join('\n\n');
  
  return BATCH_PROMPT_TEMPLATE.replace('{wordPairs}', wordPairs);
}

export function handleGeminiError(error: unknown) {
  return handleAiServiceError(error, AI_SERVICE_CONFIGS.gemini);
}
</file>

<file path="lib/openrouter.server.ts">
// Server-only OpenRouter integration
// This file should never be imported client-side

import { handleAiServiceError, AI_SERVICE_CONFIGS } from './aiUtils';

export const OPENROUTER_BASE_URL = 'https://openrouter.ai/api/v1';
export const OPENROUTER_MODEL = process.env.OPENROUTER_MODEL || 'google/gemini-2.5-flash-preview-05-20';

export interface OpenRouterMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface OpenRouterRequest {
  model: string;
  messages: OpenRouterMessage[];
  temperature?: number;
  max_tokens?: number;
  response_format?: { type: 'json_object' };
}

export async function callOpenRouter(
  messages: OpenRouterMessage[],
  options: Partial<OpenRouterRequest> = {}
): Promise<string> {
  // Read the API key directly from process.env here
  const apiKeyFromEnv = process.env.OPENROUTER_API_KEY;

  // Comprehensive check and logging for the API key
  if (!apiKeyFromEnv || typeof apiKeyFromEnv !== 'string' || apiKeyFromEnv.trim() === '') {
    const errorMsg = "OpenRouter API Key (OPENROUTER_API_KEY) is missing, empty, or not a string in environment variables. Please ensure it's correctly set in your .env.local file (and that the server was restarted) or in your deployment environment settings.";
    console.error(`CRITICAL_ERROR: callOpenRouter - ${errorMsg}`);
    // Log the actual value (or lack thereof) for debugging, being mindful of security in production logs if they are public.
    // For local development, this is very helpful.
    if (process.env.NODE_ENV === 'development') {
      console.error(`DEBUG: callOpenRouter - Value of process.env.OPENROUTER_API_KEY was: '${apiKeyFromEnv}' (type: ${typeof apiKeyFromEnv})`);
    }
    throw new Error(errorMsg);
  }
  
  // Log a masked version of the key being used in development for verification
  if (process.env.NODE_ENV === 'development') {
    const keyPreview = `${apiKeyFromEnv.substring(0, 5)}...${apiKeyFromEnv.substring(apiKeyFromEnv.length - 5)}`;
    console.log(
      `DEBUG: callOpenRouter - Using API Key (length: ${apiKeyFromEnv.length}): ${keyPreview} for OpenRouter request.`
    );
  }

  const response = await fetch(`${OPENROUTER_BASE_URL}/chat/completions`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKeyFromEnv}`, // Use the key directly from environment
      'Content-Type': 'application/json',
      'HTTP-Referer': 'https://github.com/sdxl-emoji-pipeline', // Consider making this configurable or your actual app URL
      'X-Title': 'SDXL Emoji Pipeline' // Consider making this configurable
    },
    body: JSON.stringify({
      model: OPENROUTER_MODEL,
      messages,
      temperature: 0.1,
      response_format: { type: 'json_object' },
      ...options
    })
  });

  if (!response.ok) {
    let errorResponseMessage = `OpenRouter API request failed: ${response.status} ${response.statusText}`;
    let responseBodyText = await response.text(); // Get raw text first
    
    console.error(`ERROR: callOpenRouter - OpenRouter API error (${response.status}). Response text: ${responseBodyText}`);

    try {
      const errorData = JSON.parse(responseBodyText); // Try to parse as JSON
      if (errorData && errorData.error && errorData.error.message) {
        errorResponseMessage = `OpenRouter API Error (${response.status}): ${errorData.error.message}`;
      } else if (errorData && errorData.message) {
        errorResponseMessage = `OpenRouter API Message (${response.status}): ${errorData.message}`;
      }
    } catch (e) {
      // Parsing failed, use the raw text if it's short, or a generic message
      if (responseBodyText.length < 200) {
        errorResponseMessage += `. Raw response: ${responseBodyText}`;
      }
      console.error("ERROR: callOpenRouter - Failed to parse JSON error response from OpenRouter. Raw text was logged above.");
    }
    
    if (response.status === 401) {
       errorResponseMessage = `OpenRouter Authentication Failed (401). This usually means the API Key is incorrect, invalid, or lacks permissions. Please verify OPENROUTER_API_KEY in your environment settings. Ensure no extra characters (spaces, semicolons) are present IN THE ENVIRONMENT VARIABLE VALUE ITSELF. Details: ${errorResponseMessage}`;
    }

    throw new Error(errorResponseMessage);
  }

  // If response.ok, try to parse JSON, but handle potential non-JSON success responses if any
  const responseText = await response.text();
  try {
    const data = JSON.parse(responseText);
    if (data.choices && data.choices[0] && data.choices[0].message && typeof data.choices[0].message.content === 'string') {
      return data.choices[0].message.content;
    } else {
      console.error("ERROR: callOpenRouter - OpenRouter success response has unexpected structure:", responseText);
      throw new Error("OpenRouter returned a success status but the response structure was unexpected.");
    }
  } catch (parseError) {
      console.error("ERROR: callOpenRouter - Failed to parse JSON success response from OpenRouter:", responseText, parseError);
      throw new Error("OpenRouter returned a success status but the response was not valid JSON.");
  }
}

// Batch prompt generation constants and interfaces
export const BATCH_PROMPT_GENERATION_INSTRUCTIONS = `
For each word below, generate ONE emoji object following these rules:

1. Object MUST visually represent the word's meaning
2. Maximum 4 words
3. Single object only
4. Choose most memorable/iconic association
5. If describing people, use light-skinned or yellow emoji-style characters
6. FORBIDDEN: "vibrant", "representing", "showing", generic descriptions

Think: What visual helps remember this word?

Examples:
"autumn" ‚Üí "orange fall leaf" (NOT green leaf)
"winter" ‚Üí "snowflake" (NOT generic season)
"happy" ‚Üí "smiling face"
"article" ‚Üí "newspaper"
"above" ‚Üí "upward arrow"
"actor" ‚Üí "light-skinned man in suit"
`;

// This interface matches the structure of items in GeneratePromptsBatchPayload entries from lib/apiClient.ts
export interface BatchPromptEntry {
  id: number;
  english: string;
  russian: string;
  transcription: string;
}

// Function to format batch prompt messages for OpenRouter
export function formatOpenRouterBatchPromptMessages(entries: BatchPromptEntry[]): OpenRouterMessage[] {
  const wordPairs = entries
    .map(
      (entry) =>
        `ID: ${entry.id}\nEnglish: ${entry.english} ${entry.transcription}\nRussian: ${entry.russian}`
    )
    .join('\n\n');

  const systemMessage = `You are an AI assistant. For each word pair, generate a concise visual prompt for an emoji-style image.
Return your response as a JSON array where each object has an "id" field matching the input id and a "prompt" field with the single object description.
Output only valid JSON, no markdown formatting. The "prompt" should adhere to the rules provided in the user message.
Example format: [{"id": 1, "prompt": "orange fall leaf"}, {"id": 2, "prompt": "snowflake"}]`;

  const userMessageContent = `${BATCH_PROMPT_GENERATION_INSTRUCTIONS}

Word pairs:
${wordPairs}

Return valid JSON only, no markdown formatting.`;

  return [
    { role: 'system', content: systemMessage },
    { role: 'user', content: userMessageContent },
  ];
}

export function handleOpenRouterError(error: unknown) {
  return handleAiServiceError(error, AI_SERVICE_CONFIGS.openrouter);
}
</file>

<file path="types/index.ts">
export interface CategorizationResult {
  primary_category: 'CONCRETE-VISUAL' | 'ABSTRACT-SYMBOLIC' | 'ACTION-VISUAL' | 'STATE-METAPHORICAL';
  image_suitability: 'HIGH' | 'MEDIUM' | 'LOW';
  word_type: 'noun' | 'verb' | 'adjective' | 'adverb' | 'phrase' | null;
  transformation_needed: boolean;
  transformation_suggestion: string;
  confidence: number;
}

export interface WordEntry {
  id: number;
  original_text: string;
  translation_text: string;
  level_id: number;
  transcription: string;
  prompt?: string;
  imageUrl?: string;
  imageStatus: 'none' | 'queued' | 'processing' | 'completed' | 'error';
  promptStatus: 'none' | 'generating' | 'completed' | 'error';
  replicateId?: string;
  qaScore?: 'good' | 'bad' | null;
  imageGeneratedAt?: string; // ISO timestamp when image was generated
  categorization?: CategorizationResult;
  categorizationStatus?: 'none' | 'processing' | 'completed' | 'error';
}

export interface AppState {
  entries: WordEntry[];
  currentPage: number;
  itemsPerPage: number;
  searchQuery: string;
  levelFilter: number | null;
  sortBy: string;
  sortOrder: 'asc' | 'desc';
  activeTab: 'table' | 'gallery';
}

export interface JSONImportData {
  id: number;
  original_text: string;
  translation_text: string;
  level_id: number;
  transcription: string;
}
</file>

<file path="app/api/queue-image/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { imageQueue } from '@/lib/imageQueue';
import { handleApiRequest, validateRequestBody } from '@/lib/apiUtils';

// In-memory storage for completion callbacks
const completionCallbacks = new Map<string, (result: any) => void>();
const errorCallbacks = new Map<string, (error: string) => void>();

// Set up notification handlers on the queue instance
(imageQueue as any).notifyCompletion = function(item: any, result: any) {
  const callback = completionCallbacks.get(item.id);
  if (callback) {
    callback(result);
    completionCallbacks.delete(item.id);
  }
};

(imageQueue as any).notifyError = function(item: any, error: string) {
  const errorCallback = errorCallbacks.get(item.id);
  if (errorCallback) {
    errorCallback(error);
    errorCallbacks.delete(item.id);
  }
};

export async function POST(request: NextRequest) {
  return handleApiRequest(request, async (_req, body: { action: string; [key: string]: any }) => {
    const validation = validateRequestBody(body, ['action']);
    if (!validation.valid) {
      return NextResponse.json({ error: validation.error }, { status: validation.status });
    }

    const { action, ...data } = body;

    switch (action) {
      case 'add':
        return handleAddToQueue(data);
      case 'status':
        return handleGetStatus();
      case 'items':
        return handleGetItems();
      default:
        return NextResponse.json(
          { error: 'Invalid action' },
          { status: 400 }
        );
    }
  });
}

async function handleAddToQueue(data: any) {
  const { entryId, englishWord, prompt } = data;

  console.log(`API: Adding to queue - entryId: ${entryId}, word: ${englishWord}`);

  if (!entryId || !englishWord || !prompt) {
    console.log('API: Missing required fields:', { entryId, englishWord, prompt: !!prompt });
    return NextResponse.json(
      { error: 'Missing required fields: entryId, englishWord, prompt' },
      { status: 400 }
    );
  }

  try {
    // Add to queue
    console.log(`API: Adding to imageQueue...`);
    const queueId = await imageQueue.addToQueue(entryId, englishWord, prompt);
    console.log(`API: Added to queue with ID: ${queueId}`);

    // Create a promise that resolves when the image is generated
    const resultPromise = new Promise<any>((resolve, reject) => {
      const timeout = setTimeout(() => {
        completionCallbacks.delete(queueId);
        errorCallbacks.delete(queueId);
        reject(new Error('Generation timeout'));
      }, 300000); // 5 minute timeout

      completionCallbacks.set(queueId, (result) => {
        clearTimeout(timeout);
        resolve(result);
      });

      errorCallbacks.set(queueId, (error) => {
        clearTimeout(timeout);
        reject(new Error(error));
      });
    });

    // Wait for completion
    const result = await resultPromise;

    return NextResponse.json({
      queueId,
      status: 'completed',
      ...result,
    });

  } catch (error: any) {
    console.error('Error adding to queue:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to generate image' },
      { status: 500 }
    );
  }
}

async function handleGetStatus() {
  const status = imageQueue.getQueueStatus();
  return NextResponse.json(status);
}

async function handleGetItems() {
  const items = imageQueue.getQueueItems();
  return NextResponse.json({ items });
}
</file>

<file path="lib/db/repository.ts">
import { supabaseAdmin } from '../supabaseAdmin';
import { WordEntry } from '@/types';

export class LanguageCardRepository {

  async create(entry: Omit<WordEntry, 'imageStatus' | 'promptStatus'>): Promise<WordEntry> {
    const dbEntry = {
      id: entry.id,
      original_text: entry.original_text,
      translation_text: entry.translation_text,
      level_id: entry.level_id,
      transcription: entry.transcription,
      prompt: entry.prompt || null,
      image_url: entry.imageUrl || null,
      image_status: 'none',
      prompt_status: 'none',
      categorization_status: 'none',
      replicate_id: entry.replicateId || null,
      qa_score: entry.qaScore || null,
      image_generated_at: entry.imageGeneratedAt || null,
      categorization_primary_category: entry.categorization?.primary_category || null,
      categorization_image_suitability: entry.categorization?.image_suitability || null,
      categorization_word_type: entry.categorization?.word_type || null,
      categorization_transformation_needed: entry.categorization?.transformation_needed || false,
      categorization_transformation_suggestion: entry.categorization?.transformation_suggestion || null,
      categorization_confidence: entry.categorization?.confidence || null,
    };
    
    const { data, error } = await supabaseAdmin
      .from('word_entries')
      .insert(dbEntry)
      .select()
      .single();
      
    if (error) throw error;
    return this.mapToWordEntry(data);
  }

  async update(id: number, updates: Partial<WordEntry>): Promise<WordEntry | null> {
    const dbUpdates: any = {};

    if (updates.original_text !== undefined) dbUpdates.original_text = updates.original_text;
    if (updates.translation_text !== undefined) dbUpdates.translation_text = updates.translation_text;
    if (updates.level_id !== undefined) dbUpdates.level_id = updates.level_id;
    if (updates.transcription !== undefined) dbUpdates.transcription = updates.transcription;
    if (updates.prompt !== undefined) dbUpdates.prompt = updates.prompt || null;
    if (updates.imageUrl !== undefined) dbUpdates.image_url = updates.imageUrl || null;
    if (updates.imageStatus !== undefined) dbUpdates.image_status = updates.imageStatus;
    if (updates.promptStatus !== undefined) dbUpdates.prompt_status = updates.promptStatus;
    if (updates.replicateId !== undefined) dbUpdates.replicate_id = updates.replicateId || null;
    if (updates.qaScore !== undefined) dbUpdates.qa_score = updates.qaScore || null;
    if (updates.imageGeneratedAt !== undefined) dbUpdates.image_generated_at = updates.imageGeneratedAt || null;
    
    // Handle categorization updates
    if (updates.categorization !== undefined) {
      const cat = updates.categorization;
      dbUpdates.categorization_primary_category = cat.primary_category;
      dbUpdates.categorization_image_suitability = cat.image_suitability;
      dbUpdates.categorization_word_type = (cat.word_type === undefined || cat.word_type === null) ? null : cat.word_type;
      dbUpdates.categorization_transformation_needed = cat.transformation_needed;
      dbUpdates.categorization_transformation_suggestion = cat.transformation_suggestion;
      dbUpdates.categorization_confidence = cat.confidence;
    }
    if (updates.categorizationStatus !== undefined) dbUpdates.categorization_status = updates.categorizationStatus;

    const { data, error } = await supabaseAdmin
      .from('word_entries')
      .update(dbUpdates)
      .eq('id', id)
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null; // No rows found
      throw error;
    }
    
    return data ? this.mapToWordEntry(data) : null;
  }

  async delete(id: number): Promise<boolean> {
    const { error } = await supabaseAdmin
      .from('word_entries')
      .delete()
      .eq('id', id);
      
    return !error;
  }

  async findById(id: number): Promise<WordEntry | null> {
    const { data, error } = await supabaseAdmin
      .from('word_entries')
      .select('*')
      .eq('id', id)
      .single();
      
    if (error) {
      if (error.code === 'PGRST116') return null; // No rows found
      throw error;
    }
    
    return this.mapToWordEntry(data);
  }

  async findAll(): Promise<WordEntry[]> {
    const { data, error } = await supabaseAdmin
      .from('word_entries')
      .select('*')
      .order('id', { ascending: true })
      .limit(5000); // Fetch up to 5000 rows to override the default 1000 limit
      
    if (error) throw error;
    
    return data.map(row => this.mapToWordEntry(row));
  }

  async upsert(entry: WordEntry): Promise<WordEntry> {
    const dbEntry = {
      id: entry.id,
      original_text: entry.original_text,
      translation_text: entry.translation_text,
      level_id: entry.level_id,
      transcription: entry.transcription,
      prompt: entry.prompt || null,
      image_url: entry.imageUrl || null,
      image_status: entry.imageStatus,
      prompt_status: entry.promptStatus,
      categorization_status: entry.categorizationStatus || 'none',
      replicate_id: entry.replicateId || null,
      qa_score: entry.qaScore || null,
      image_generated_at: entry.imageGeneratedAt || null,
      categorization_primary_category: entry.categorization?.primary_category || null,
      categorization_image_suitability: entry.categorization?.image_suitability || null,
      categorization_word_type: entry.categorization?.word_type || null,
      categorization_transformation_needed: entry.categorization?.transformation_needed || false,
      categorization_transformation_suggestion: entry.categorization?.transformation_suggestion || null,
      categorization_confidence: entry.categorization?.confidence || null,
    };
    
    const { data, error } = await supabaseAdmin
      .from('word_entries')
      .upsert(dbEntry, { onConflict: 'id' })
      .select()
      .single();
      
    if (error) throw error;
    return this.mapToWordEntry(data);
  }

  async bulkUpsert(entries: WordEntry[]): Promise<WordEntry[]> {
    const dbEntries = entries.map(entry => ({
      id: entry.id,
      original_text: entry.original_text,
      translation_text: entry.translation_text,
      level_id: entry.level_id,
      transcription: entry.transcription,
      prompt: entry.prompt || null,
      image_url: entry.imageUrl || null,
      image_status: entry.imageStatus,
      prompt_status: entry.promptStatus,
      categorization_status: entry.categorizationStatus || 'none',
      replicate_id: entry.replicateId || null,
      qa_score: entry.qaScore || null,
      image_generated_at: entry.imageGeneratedAt || null,
      categorization_primary_category: entry.categorization?.primary_category || null,
      categorization_image_suitability: entry.categorization?.image_suitability || null,
      categorization_word_type: entry.categorization?.word_type || null,
      categorization_transformation_needed: entry.categorization?.transformation_needed || false,
      categorization_transformation_suggestion: entry.categorization?.transformation_suggestion || null,
      categorization_confidence: entry.categorization?.confidence || null,
    }));
    
    const { data, error } = await supabaseAdmin
      .from('word_entries')
      .upsert(dbEntries, { onConflict: 'id' })
      .select();
      
    if (error) throw error;
    
    return data.map(row => this.mapToWordEntry(row));
  }

  private mapToWordEntry(row: any): WordEntry {
    const entry: WordEntry = {
      id: row.id,
      original_text: row.original_text,
      translation_text: row.translation_text,
      level_id: row.level_id,
      transcription: row.transcription,
      prompt: row.prompt || undefined,
      imageUrl: row.image_url || undefined,
      imageStatus: row.image_status,
      promptStatus: row.prompt_status,
      replicateId: row.replicate_id || undefined,
      qaScore: row.qa_score,
      imageGeneratedAt: row.image_generated_at || undefined,
    };
    
    // Map categorization if present
    if (row.categorization_primary_category) {
      entry.categorization = {
        primary_category: row.categorization_primary_category,
        image_suitability: row.categorization_image_suitability!,
        word_type: row.categorization_word_type,
        transformation_needed: row.categorization_transformation_needed === true,
        transformation_suggestion: row.categorization_transformation_suggestion || '',
        confidence: row.categorization_confidence || 0,
      };
    }
    
    entry.categorizationStatus = row.categorization_status || 'none';
    
    return entry;
  }
}

// Export singleton instance
export const languageCardRepository = new LanguageCardRepository();
</file>

<file path="lib/batchUtils.ts">
import { WordEntry } from '@/types';
import { ApiResponse } from './apiClient';
import { activityManager } from '@/components/ActivityLog';

export interface BatchProcessorConfig<TPayload, TResult, TError> {
  itemsToProcess: WordEntry[];
  batchSize: number;
  delayBetweenBatchesMs: number;
  operationName: string;
  getBatchPayload: (batch: WordEntry[]) => TPayload;
  batchApiService: (payload: TPayload) => Promise<ApiResponse<any>>;
  getSuccessItems: (responseData: any, batchItems: WordEntry[]) => TResult[];
  getErrorItems: (responseData: any) => TError[];
  processItemSuccess: (itemResult: TResult, originalEntry: WordEntry) => void;
  processItemError: (itemError: TError, originalEntry?: WordEntry) => void;
  onStartProcessingItem?: (entry: WordEntry) => void;
}

export interface BatchProcessorResult {
  totalProcessed: number;
  totalSuccess: number;
  totalFailed: number;
}

export async function processBatch<TPayload, TResult extends { id: number }, TError extends { id?: number }>(
  config: BatchProcessorConfig<TPayload, TResult, TError>
): Promise<BatchProcessorResult> {
  const {
    itemsToProcess,
    batchSize,
    delayBetweenBatchesMs,
    operationName,
    getBatchPayload,
    batchApiService,
    getSuccessItems,
    getErrorItems,
    processItemSuccess,
    processItemError,
    onStartProcessingItem
  } = config;
  const operationKey = `batch-${operationName.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`;

  let totalProcessed = 0;
  let totalSuccess = 0;
  let totalFailed = 0;

  activityManager.addActivity(operationKey, `Starting ${operationName}...`, 'info');

  const batches = [];
  for (let i = 0; i < itemsToProcess.length; i += batchSize) {
    batches.push(itemsToProcess.slice(i, i + batchSize));
  }

  for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
    const batch = batches[batchIndex];
    const batchNumber = batchIndex + 1;

    if (onStartProcessingItem) {
      batch.forEach(entry => onStartProcessingItem(entry));
    }

    activityManager.addActivity(
      `${operationKey}-batch-${batchNumber}`,
      `Processing batch ${batchNumber} of ${batches.length} (${batch.length} items)...`,
      'info'
    );

    try {
      const payload = getBatchPayload(batch);
      const response = await batchApiService(payload);

      if (response.error) {
        activityManager.addActivity(
          `${operationKey}-batch-${batchNumber}-error`,
          `Batch ${batchNumber} failed: ${response.error}`,
          'error'
        );
        
        batch.forEach(entry => {
          processItemError({ id: entry.id } as TError, entry);
          totalFailed++;
        });
      } else if (response.data) {
        const successItems = getSuccessItems(response.data, batch);
        const errorItems = getErrorItems(response.data);

        successItems.forEach(result => {
          const originalEntry = batch.find(entry => entry.id === result.id);
          if (originalEntry) {
            processItemSuccess(result, originalEntry);
            totalSuccess++;
          }
        });

        errorItems.forEach(error => {
          const originalEntry = error.id ? batch.find(entry => entry.id === error.id) : undefined;
          processItemError(error, originalEntry);
          totalFailed++;
          
          if (error.id && 'error' in error) {
            const errorMessage = (error as any).error;
            const entryText = originalEntry ? `Word "${originalEntry.original_text}" (ID: ${error.id})` : `Item ${error.id}`;
            activityManager.addActivity(
              `${operationKey}-item-${error.id}-error`,
              `${entryText} failed: ${errorMessage}`,
              'error'
            );
          }
        });

        activityManager.addActivity(
          `${operationKey}-batch-${batchNumber}-complete`,
          `Batch ${batchNumber} completed: ${successItems.length} successful, ${errorItems.length} failed`,
          'success'
        );
      }

      totalProcessed += batch.length;

      if (batchIndex < batches.length - 1) {
        await new Promise(resolve => setTimeout(resolve, delayBetweenBatchesMs));
      }
    } catch (error) {
      activityManager.addActivity(
        `${operationKey}-batch-${batchNumber}-exception`,
        `Batch ${batchNumber} encountered an error: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'error'
      );
      
      batch.forEach(entry => {
        processItemError({ id: entry.id } as TError, entry);
        totalFailed++;
      });
      
      totalProcessed += batch.length;
    }
  }

  activityManager.addActivity(
    `${operationKey}-complete`,
    `${operationName} completed: ${totalSuccess} successful, ${totalFailed} failed out of ${totalProcessed} processed`,
    totalFailed === 0 ? 'success' : 'warning'
  );

  return {
    totalProcessed,
    totalSuccess,
    totalFailed
  };
}
</file>

<file path="components/Gallery.tsx">
'use client';

import { useState, useMemo, useEffect } from 'react';
import { useAppStore } from '@/store/useAppStore';
import { WordEntry } from '@/types';
import { RefreshCw, Download, RefreshCcw } from 'lucide-react';
import toast from 'react-hot-toast';
import { activityManager } from './ActivityLog';
import { queueImageService, generatePromptsBatchService } from '@/lib/apiClient';
import { processBatch } from '@/lib/batchUtils';

export default function Gallery() {
  const { entries, updateEntry } = useAppStore();
  const [qaFilter, setQaFilter] = useState<'all' | 'good' | 'bad' | 'unrated'>('all');
  const [galleryImages, setGalleryImages] = useState<any[]>([]);

  // Load gallery images from JSON
  useEffect(() => {
    fetch('/api/gallery')
      .then(res => res.json())
      .then(data => setGalleryImages(data.images || []))
      .catch(err => console.error('Failed to load gallery:', err));
  }, []);

  const entriesWithImages = useMemo(() => {
    return entries.filter(entry => entry.imageUrl && entry.imageStatus === 'completed');
  }, [entries]);

  // Combine entries with standalone gallery images
  const allImages = useMemo(() => {
    const entryImages = entriesWithImages.map(entry => ({
      ...entry,
      source: 'entries'
    }));
    
    const standaloneImages = galleryImages
      .filter(img => !entriesWithImages.find(entry => entry.id === img.id))
      .map(img => {
        // Find matching entry from all entries (including those without images)
        const matchingEntry = entries.find(entry => entry.id === img.id);
        
        return {
          id: img.id,
          original_text: matchingEntry?.original_text || `Image ${img.id}`,
          translation_text: matchingEntry?.translation_text || '',
          transcription: matchingEntry?.transcription || '',
          imageUrl: `/images/${img.id}.png`,
          imageStatus: 'completed',
          source: 'gallery',
          prompt: matchingEntry?.prompt
        };
      });
    
    return [...entryImages, ...standaloneImages];
  }, [entriesWithImages, galleryImages, entries]);

  const filteredEntries = useMemo(() => {
    let filtered = allImages;
    
    // Apply QA filter
    if (qaFilter === 'good') {
      filtered = filtered.filter(entry => entry.qaScore === 'good');
    } else if (qaFilter === 'bad') {
      filtered = filtered.filter(entry => entry.qaScore === 'bad');
    } else if (qaFilter === 'unrated') {
      filtered = filtered.filter(entry => !entry.qaScore);
    }
    
    // Sort by generation date - newest images first
    filtered.sort((a, b) => {
      const dateA = a.imageGeneratedAt ? new Date(a.imageGeneratedAt).getTime() : 0;
      const dateB = b.imageGeneratedAt ? new Date(b.imageGeneratedAt).getTime() : 0;
      return dateB - dateA; // Descending order - newest first, oldest last
    });
    
    return filtered;
  }, [allImages, qaFilter]);

  const handleQaScore = (entryId: number, score: 'good' | 'bad') => {
    updateEntry(entryId, { qaScore: score });
    toast.success(`Marked as ${score === 'good' ? '‚úÖ Good' : '‚ùå Bad'}`);
  };

  const handleRegenerateImage = async (entry: WordEntry) => {
    if (!entry.prompt) {
      toast.error('No prompt available for regeneration');
      return;
    }

    const operationKey = `regen-image-${entry.id}`;
    updateEntry(entry.id, { imageStatus: 'queued' });
    activityManager.addActivity('loading', `Queuing regeneration for "${entry.original_text}"`, undefined, operationKey);
    
    const result = await queueImageService({
      action: 'add',
      entryId: entry.id,
      englishWord: entry.original_text,
      prompt: entry.prompt,
    });

    if (result.data && result.data.status === 'completed' && result.data.imageUrl) {
      updateEntry(entry.id, { 
        imageUrl: result.data.imageUrl, 
        imageStatus: 'completed',
        qaScore: null, // Reset QA score for new image
        imageGeneratedAt: result.data.generatedAt // Update generation timestamp
      });
      activityManager.addActivity('success', `Image regenerated for "${entry.original_text}"`, undefined, operationKey);
      toast.success('Image regenerated successfully');
    } else {
      updateEntry(entry.id, { imageStatus: 'completed' }); // Revert to previous state
      activityManager.addActivity('error', `Failed to regenerate image for "${entry.original_text}"`, result.error || 'Failed to regenerate image', operationKey);
      toast.error(`Failed to regenerate: ${result.error || 'Unknown error'}`);
    }
  };

  // Image download functionality has been removed

  const handleExportAll = () => {
    activityManager.addActivity('loading', 'Exporting data...');
    
    try {
      const exportData = entries.map(entry => ({
        ...entry,
        imageStatus: undefined,
        promptStatus: undefined,
        replicateId: undefined,
      }));
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'language-cards-export.json';
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
      
      const stats = {
        total: entries.length,
        withPrompts: entries.filter(e => e.prompt).length,
        withImages: entries.filter(e => e.imageUrl).length,
      };
      
      activityManager.addActivity('success', 'Data exported successfully', 
        `${stats.total} entries, ${stats.withPrompts} prompts, ${stats.withImages} images`);
    } catch (error) {
      activityManager.addActivity('error', 'Failed to export data');
    }
  };

  const handleBatchRefreshBadPrompts = async () => {
    // Filter entries with bad QA score - use all entries, not just filtered gallery images
    const badEntries = entries.filter(entry => entry.qaScore === 'bad');
    
    if (badEntries.length === 0) {
      toast.error('No bad entries found');
      return;
    }

    activityManager.addActivity('info', `Starting batch refresh for ${badEntries.length} bad entries...`);

    const result = await processBatch({
      itemsToProcess: badEntries,
      batchSize: badEntries.length, // Process all at once for prompts
      delayBetweenBatchesMs: 0,
      operationName: 'Batch Refresh Bad Prompts',
      getBatchPayload: (batch) => ({
        entries: batch.map(entry => ({
          id: entry.id,
          english: entry.original_text,
          russian: entry.translation_text,
          transcription: entry.transcription,
        })),
      }),
      batchApiService: generatePromptsBatchService,
      getSuccessItems: (responseData, batchItems) => responseData.prompts || [],
      getErrorItems: (responseData) => [], // generatePromptsBatchService doesn't return separate errors array
      processItemSuccess: (result, originalEntry) => {
        updateEntry(result.id, {
          prompt: result.prompt,
          promptStatus: result.prompt === 'Failed to generate prompt' ? 'error' : 'completed',
          qaScore: null,          // Reset QA score
          imageUrl: null,         // Remove old image URL
          imageStatus: 'none'     // Reset image status for new generation
        });
        activityManager.addActivity('success', `Refreshed prompt for "${originalEntry.original_text}"`);
      },
      processItemError: (error, originalEntry) => {
        if (originalEntry) {
          updateEntry(originalEntry.id, { promptStatus: 'error' });
          activityManager.addActivity('error', `Failed to refresh prompt for "${originalEntry.original_text}"`);
        }
      },
      onStartProcessingItem: (entry) => {
        updateEntry(entry.id, { promptStatus: 'generating' });
      },
    });

    const message = `Refreshed ${result.totalSuccess} prompts. ${result.totalFailed > 0 ? `${result.totalFailed} failed.` : ''}`;
    activityManager.addActivity('info', message);
    toast.success(message);
  };

  if (allImages.length === 0) {
    return (
      <div className="text-center py-12">
        <p className="text-gray-400">No images found</p>
        <p className="text-sm mt-2 text-gray-500">
          Go to the Data Table tab to generate images or add images to public/images/
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Filters */}
      <div className="flex justify-between items-center">
        <div className="flex gap-4 items-center">
          <select
            value={qaFilter}
            onChange={(e) => setQaFilter(e.target.value as 'all' | 'good' | 'bad' | 'unrated')}
            className="input-field w-40"
          >
            <option value="all">All Images</option>
            <option value="good">‚úÖ Good Images</option>
            <option value="bad">‚ùå Bad Images</option>
            <option value="unrated">‚ö™ Unrated</option>
          </select>
          
          <span className="text-sm text-gray-400">
            {filteredEntries.length} cards
          </span>
        </div>
        
        <div className="flex gap-2">
          {/* Show refresh button when there are bad entries */}
          {entries.filter(entry => entry.qaScore === 'bad').length > 0 && (
            <button
              onClick={handleBatchRefreshBadPrompts}
              className="btn-secondary flex items-center gap-2"
              title="Generate new prompts for all bad entries"
            >
              <RefreshCcw className="h-4 w-4" />
              Refresh Bad ({entries.filter(entry => entry.qaScore === 'bad').length})
            </button>
          )}
          
          <button onClick={handleExportAll} className="btn-primary">
            <Download className="h-4 w-4" />
            [EXPORT]
          </button>
        </div>
      </div>

      {/* Gallery Grid */}
      <div className="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 gap-3">
        {filteredEntries.map((entry) => {
          return (
            <div key={entry.id} className="bg-gray-900 border border-gray-700 rounded overflow-hidden group hover:border-gray-600 transition-colors">
              {/* Compact Image Display */}
              <div className="relative w-full aspect-square">
                <img
                  src={entry.imageUrl!}
                  alt={entry.original_text}
                  className="w-full h-full object-contain bg-gray-800"
                />
                
                {/* QA Score Indicator */}
                {entry.qaScore && (
                  <div className="absolute top-1 right-1 w-5 h-5 rounded-full text-xs flex items-center justify-center bg-black/60">
                    {entry.qaScore === 'good' ? '‚úÖ' : '‚ùå'}
                  </div>
                )}
              </div>
              
              {/* Compact Card Info */}
              <div className="p-2 space-y-2">
                {/* Word Info */}
                <div>
                  <h3 className="font-medium text-gray-100 text-sm truncate" title={entry.original_text}>
                    {entry.original_text}
                  </h3>
                  <p className="text-xs text-gray-400 truncate" title={entry.translation_text}>
                    {entry.translation_text}
                  </p>
                  <div className="text-xs text-gray-500">ID: {entry.id}</div>
                </div>
                
                {/* Compact Buttons */}
                <div className="flex gap-1">
                  <button
                    onClick={() => handleQaScore(entry.id, 'good')}
                    className={`flex-1 py-1 px-2 rounded text-xs transition-colors ${
                      entry.qaScore === 'good'
                        ? 'bg-green-600 text-white'
                        : 'bg-gray-800 text-gray-300 hover:bg-green-600/20'
                    }`}
                    title="Mark as good"
                  >
                    ‚úÖ
                  </button>
                  <button
                    onClick={() => handleQaScore(entry.id, 'bad')}
                    className={`flex-1 py-1 px-2 rounded text-xs transition-colors ${
                      entry.qaScore === 'bad'
                        ? 'bg-red-600 text-white'
                        : 'bg-gray-800 text-gray-300 hover:bg-red-600/20'
                    }`}
                    title="Mark as bad"
                  >
                    ‚ùå
                  </button>
                  <button
                    onClick={() => handleRegenerateImage(entry)}
                    disabled={entry.imageStatus === 'processing'}
                    className="flex-1 py-1 px-2 bg-blue-800 text-blue-300 hover:bg-blue-700 disabled:bg-gray-800 disabled:text-gray-500 rounded text-xs transition-colors"
                    title="Regenerate image"
                  >
                    {entry.imageStatus === 'processing' ? (
                      <div className="loading-spinner h-3 w-3 mx-auto" />
                    ) : (
                      <RefreshCw className="h-3 w-3 mx-auto" />
                    )}
                  </button>
                </div>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="lib/apiClient.ts">
import { WordEntry, CategorizationResult } from '@/types';

// Generic API response type
export interface ApiResponse<T = any> {
  data?: T;
  error?: string;
  status: number;
}

// Request payload types
export interface GeneratePromptPayload {
  entryId: number;
  english: string;
  russian: string;
  transcription: string;
}

export interface QueueImagePayload {
  action: 'add';
  entryId: number;
  englishWord: string;
  prompt: string;
}

export interface GeneratePromptsBatchPayload {
  entries: Array<{
    id: number;
    english: string;
    russian: string;
    transcription: string;
  }>;
}

export interface CategorizeVocabularyPayload {
  entries: Array<{
    id: number;
    original_text: string;
    translation_text: string;
    level_id: number;
  }>;
}

export interface RegenerateImagePayload {
  entryId: number;
  prompt: string;
}

export interface LanguageCardsPayload {
  word: string;
}

export interface BatchGenerateImagesPayload {
  entries: Array<{
    entryId: number;
    prompt: string;
    englishWord: string;
  }>;
}

// Response types
export interface GeneratePromptResponse {
  prompt: string;
}

export interface QueueImageResponse {
  status: string;
  imageUrl?: string;
  generatedAt?: string;
}

export interface GeneratePromptsBatchResponse {
  prompts: Array<{
    id: number;
    prompt: string;
  }>;
}

export interface CategorizeVocabularyResponse {
  results: Array<{
    id: number;
    categorization: CategorizationResult;
  }>;
  errors: Array<{
    id: number;
    error: string;
  }>;
}

export interface RegenerateImageResponse {
  success: boolean;
  imageUrl?: string;
  generatedAt?: string;
  error?: string;
}

export interface LanguageCardsResponse {
  cards: WordEntry[];
  totalWords: number;
}

export interface BatchGenerateImagesResponse {
  success: boolean;
  message: string;
  queuedCount: number;
  errorCount: number;
  errors?: Array<{
    entryId: number;
    error: string;
  }>;
}

// Generic API call utility
async function apiCall<T>(
  endpoint: string,
  options: {
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
    body?: any;
  } = {}
): Promise<ApiResponse<T>> {
  const { method = 'GET', body } = options;

  try {
    const response = await fetch(endpoint, {
      method,
      headers: {
        'Content-Type': 'application/json',
      },
      ...(body && { body: JSON.stringify(body) }),
    });

    const status = response.status;

    if (!response.ok) {
      // Try to parse error message from response
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return {
        error: errorData.error || `HTTP ${status}`,
        status,
      };
    }

    const data = await response.json();
    return {
      data,
      status,
    };
  } catch (error) {
    return {
      error: error instanceof Error ? error.message : 'Network error',
      status: 0,
    };
  }
}

// Service functions
export async function generatePromptService(
  payload: GeneratePromptPayload
): Promise<ApiResponse<GeneratePromptResponse>> {
  return apiCall<GeneratePromptResponse>('/api/generate-prompt', {
    method: 'POST',
    body: payload,
  });
}

export async function queueImageService(
  payload: QueueImagePayload
): Promise<ApiResponse<QueueImageResponse>> {
  return apiCall<QueueImageResponse>('/api/queue-image', {
    method: 'POST',
    body: payload,
  });
}

export async function generatePromptsBatchService(
  payload: GeneratePromptsBatchPayload
): Promise<ApiResponse<GeneratePromptsBatchResponse>> {
  return apiCall<GeneratePromptsBatchResponse>('/api/generate-prompts-batch', {
    method: 'POST',
    body: payload,
  });
}

export async function categorizeVocabularyService(
  payload: CategorizeVocabularyPayload
): Promise<ApiResponse<CategorizeVocabularyResponse>> {
  return apiCall<CategorizeVocabularyResponse>('/api/categorize-vocabulary', {
    method: 'POST',
    body: payload,
  });
}

export async function regenerateImageService(
  payload: RegenerateImagePayload
): Promise<ApiResponse<RegenerateImageResponse>> {
  return apiCall<RegenerateImageResponse>('/api/generate-image', {
    method: 'POST',
    body: payload,
  });
}

export async function fetchLanguageCardsService(
  payload: LanguageCardsPayload
): Promise<ApiResponse<LanguageCardsResponse>> {
  return apiCall<LanguageCardsResponse>(`/api/language-cards?word=${encodeURIComponent(payload.word)}`, {
    method: 'GET',
  });
}

export async function batchGenerateImagesService(
  payload: BatchGenerateImagesPayload
): Promise<ApiResponse<BatchGenerateImagesResponse>> {
  return apiCall<BatchGenerateImagesResponse>('/api/generate-images-batch', {
    method: 'POST',
    body: payload,
  });
}

export async function clearQueueService(): Promise<ApiResponse<{ clearedCount: number }>> {
  return apiCall<{ clearedCount: number }>('/api/clear-queue', {
    method: 'POST',
  });
}
</file>

<file path="store/useAppStore.ts">
import { create } from 'zustand';
import { WordEntry, AppState } from '@/types';

interface AppStore extends AppState {
  setEntries: (entries: WordEntry[]) => void;
  updateEntry: (id: number, updates: Partial<WordEntry>) => void;
  setCurrentPage: (page: number) => void;
  setItemsPerPage: (items: number) => void;
  setSearchQuery: (query: string) => void;
  setLevelFilter: (level: number | null) => void;
  setSortBy: (field: string) => void;
  setSortOrder: (order: 'asc' | 'desc') => void;
  setActiveTab: (tab: 'table' | 'gallery') => void;
  getFilteredEntries: () => WordEntry[];
  clearData: () => void;
  syncWithDatabase: () => Promise<void>;
  loadFromDatabase: () => Promise<void>;
  isInitialized: boolean;
}

const initialState: AppState = {
  entries: [],
  currentPage: 1,
  itemsPerPage: 100,
  searchQuery: '',
  levelFilter: null,
  sortBy: 'id',
  sortOrder: 'asc',
  activeTab: 'table',
};

export const useAppStore = create<AppStore>()((set, get) => ({
      ...initialState,
      isInitialized: false,
      
      setEntries: async (entries) => {
        set({ entries, currentPage: 1 });
        
        // Sync to database in background
        try {
          await fetch('/api/language-cards', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(entries),
          });
        } catch (error) {
          console.error('Failed to sync entries to database:', error);
        }
      },
      
      updateEntry: async (id, updates) => {
        set((state) => ({
          entries: state.entries.map((entry) =>
            entry.id === id ? { ...entry, ...updates } : entry
          ),
        }));
        
        // Update in database
        try {
          await fetch('/api/language-cards', {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id, updates }),
          });
        } catch (error) {
          console.error('Failed to update entry in database:', error);
        }
      },
      
      setCurrentPage: (currentPage) => set({ currentPage }),
      setItemsPerPage: (itemsPerPage) => set({ itemsPerPage, currentPage: 1 }),
      setSearchQuery: (searchQuery) => set({ searchQuery, currentPage: 1 }),
      setLevelFilter: (levelFilter) => set({ levelFilter, currentPage: 1 }),
      setSortBy: (sortBy) => set({ sortBy }),
      setSortOrder: (sortOrder) => set({ sortOrder }),
      setActiveTab: (activeTab) => set({ activeTab }),
      
      getFilteredEntries: () => {
        const state = get();
        let filtered = [...state.entries];
        
        // Apply search filter
        if (state.searchQuery) {
          const query = state.searchQuery.toLowerCase();
          filtered = filtered.filter(
            (entry) =>
              entry.original_text.toLowerCase().includes(query) ||
              entry.translation_text.toLowerCase().includes(query) ||
              entry.transcription.toLowerCase().includes(query) ||
              (entry.prompt && entry.prompt.toLowerCase().includes(query))
          );
        }
        
        // Apply level filter
        if (state.levelFilter !== null) {
          filtered = filtered.filter((entry) => entry.level_id === state.levelFilter);
        }
        
        // Apply sorting
        filtered.sort((a, b) => {
          let aVal = a[state.sortBy as keyof WordEntry];
          let bVal = b[state.sortBy as keyof WordEntry];
          
          if (aVal === undefined || bVal === undefined) return 0;
          
          if (typeof aVal === 'string' && typeof bVal === 'string') {
            aVal = aVal.toLowerCase();
            bVal = bVal.toLowerCase();
          }
          
          if (aVal < bVal) return state.sortOrder === 'asc' ? -1 : 1;
          if (aVal > bVal) return state.sortOrder === 'asc' ? 1 : -1;
          return 0;
        });
        
        return filtered;
      },
      
      clearData: async () => {
        set(initialState);
        // Note: We don't clear the database here to preserve data
      },
      
      syncWithDatabase: async () => {
        const state = get();
        if (state.entries.length > 0) {
          try {
            await fetch('/api/language-cards', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(state.entries),
            });
          } catch (error) {
            console.error('Failed to sync with database:', error);
          }
        }
      },
      
      loadFromDatabase: async () => {
        set(state => ({ ...state, isInitialized: false })); // Indicate loading starts
        try {
          const response = await fetch('/api/language-cards');
          if (response.ok) {
            let loadedEntries: WordEntry[] = await response.json();
            const entries = loadedEntries.map(entry => {
              const updatedEntry = { ...entry };
              if (updatedEntry.promptStatus === 'generating') {
                // Prompt generation was interrupted, reset status
                updatedEntry.promptStatus = 'error'; 
                console.log(`Resetting stuck promptStatus 'generating' to 'error' for entry ID ${entry.id}`);
              }
              if (updatedEntry.imageStatus === 'processing') {
                // Single image generation was interrupted, reset status
                updatedEntry.imageStatus = 'error';
                console.log(`Resetting stuck imageStatus 'processing' to 'error' for entry ID ${entry.id}`);
              }
              if (updatedEntry.imageStatus === 'queued') {
                // If it's 'queued' and has an image, it's likely an error or incomplete update from a previous batch.
                // If it's 'queued' and has NO image, it's a truly stale queue item that never started.
                if (updatedEntry.imageUrl) {
                    updatedEntry.imageStatus = 'error';
                    console.log(`Resetting stuck imageStatus 'queued' (with image) to 'error' for entry ID ${entry.id}`);
                } else {
                    updatedEntry.imageStatus = 'none';
                    console.log(`Resetting stuck imageStatus 'queued' (no image) to 'none' for entry ID ${entry.id}`);
                }
              }
              return updatedEntry;
            });
            set({ entries, isInitialized: true });
          } else {
            console.error('Failed to load from database, server responded with an error:', response.status);
            set({ entries: [], isInitialized: true }); // Initialize with empty on server error, but mark as done
          }
        } catch (error) {
          console.error('Failed to load from database (network error or JSON parsing issue):', error);
          set({ entries: [], isInitialized: true }); // Initialize with empty on catch, but mark as done
        }
      },
    }));

// Initialize database on first load
if (typeof window !== 'undefined') {
  useAppStore.getState().loadFromDatabase();
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# generated images
/public/images

# database files
/data/*.db
/data/*.db-journal
/data/*.db-wal
/data/*.db-shm
/data/*.backup-*
*.db
*.db-journal
*.db-wal
*.db-shm

# localStorage exports
language-cards-export.json
localStorage-backup-*.json
.localStorage-backup.json

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE / Editor files
.vscode/
.idea/
*.swp
*.swo
*~
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# OS files
Thumbs.db
.Spotlight-V100
.Trashes

# Temporary files
*.tmp
*.temp
.tmp/
.temp/

# Build artifacts
dist/
*.log

# Tool-generated files
repomix-output.xml
repomix-output.txt

# Backup files
*.backup
*.bak
*.old

# Archive files
*.zip
*.tar.gz
*.rar

# Nodemon
nodemon.json

# Cache directories
.cache/
.parcel-cache/

repomix-output.xml
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

SDXL Emoji Pipeline is a Next.js application that generates emoji-style images for language learning vocabulary cards. It processes JSON vocabulary data, uses AI to categorize words and generate prompts, then creates emoji-style images using SDXL-emoji model.

## Commands

```bash
# Development
npm run dev          # Start development server with Turbopack on http://localhost:3000

# Production
npm run build        # Build for production
npm run start        # Start production server

# Code Quality
npm run lint         # Run ESLint
```

## Architecture

- **Next.js 15.3.2 App Router**: All pages in `/app`, API routes in `/app/api`
- **Database**: Supabase (cloud) with repository pattern in `/lib/db/repository.ts`
- **State Management**: Zustand store in `/store/useAppStore.ts`
- **AI Integration**:
  - OpenRouter API (with Gemini model) for categorization
  - Google Gemini AI for prompt generation
  - Replicate API with SDXL-emoji model for image generation
- **Image Storage**: Supabase Storage with automatic upload after generation

## Key Workflows

1. **Word Categorization**: `/app/api/categorize-vocabulary` determines if words are suitable for image generation and provides transformation suggestions for abstract words
2. **Prompt Generation**: Smart layered approach in `/app/api/generate-prompt` and `/app/api/generate-prompts-batch`:
   - Priority 1: YAML overrides from `prompt_overrides.yaml`
   - Priority 2: Database transformation suggestions from categorization
   - Priority 3: AI generation (only when needed)
3. **Image Generation**: Queue system in `/lib/imageQueue.ts` handles sequential processing and automatically updates database with results
4. **Database Operations**: Repository pattern in `/lib/db/repository.ts` with 5000-row limit for full dataset access
5. **Random Pending Word**: `/app/api/random-pending-word` returns random word with `image_status != 'completed'` as `{id, prompt}` for n8n integration

## Environment Variables

Required in `.env.local`:
```
GEMINI_API_KEY=your_google_gemini_key
REPLICATE_API_TOKEN=your_replicate_token
OPENROUTER_API_KEY=your_openrouter_key  # Optional, defaults to provided key
OPENROUTER_MODEL=google/gemini-2.5-flash-preview-05-20  # Optional

# Supabase
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key
```

## Important Implementation Details

### Prompt Generation Optimization
- The system leverages categorization results to avoid redundant AI calls
- Abstract words use pre-computed `transformation_suggestion` from categorization
- Categorization prompts generate clean, direct suggestions (no "emoji" word, max 4 words)
- This significantly reduces API costs and improves consistency

### Image Queue Processing
- `/lib/imageQueue.ts` automatically updates the database after successful/failed image generation
- No manual database updates needed - the queue handles persistence
- Includes retry logic with exponential backoff for failed generations

### Database Query Limits
- Repository `findAll()` method uses `.limit(5000)` to override Supabase's default 1000-row limit
- Gallery API removes hardcoded slice limits to display all entries
- Supports 4000+ vocabulary entries without pagination

## API Response Patterns

All API routes return consistent JSON:
- Success: `{ success: true, data: ... }`
- Error: `{ success: false, error: "message" }`

## Testing

No test framework is currently configured. When adding tests, update this section with the test command.
</file>

<file path="README.md">
# SDXL Emoji Pipeline

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/YOUR_USERNAME/sdxl-emoji-pipeline)

## tech

Next.js / Gemini AI / Replicate SDXL-emoji / Vercel Postgres / Vercel Blob

## Environment Variables for Vercel Deployment

Make sure to set these environment variables in your Vercel project settings:

| Variable                | Description                               | Example Value                      |
|-------------------------|-------------------------------------------|------------------------------------|
| `DATABASE_URL`          | Vercel Postgres Connection String         | `postgres://...`                   |
| `BLOB_READ_WRITE_TOKEN` | Vercel Blob Read/Write Token            | `vercel_blob_rw_...`               |
| `GEMINI_API_KEY`        | Google Gemini API Key                     | `your_google_gemini_key`           |
| `REPLICATE_API_TOKEN`   | Replicate API Token                       | `your_replicate_token`             |
| `OPENROUTER_API_KEY`    | OpenRouter API Key (optional, has default) | `sk-or-v1...`                      |

### –ö–∞–∫ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–µ–∫—Ç

1. **–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:**
```bash
npm install
```

2. **–°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª `.env.local` —Å API –∫–ª—é—á–∞–º–∏:**
```env
GEMINI_API_KEY=–≤–∞—à_–∫–ª—é—á_google_gemini
REPLICATE_API_TOKEN=–≤–∞—à_—Ç–æ–∫–µ–Ω_replicate
```

3. **–ó–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–æ–µ–∫—Ç:**
```bash
npm run dev
```

4. **–û—Ç–∫—Ä–æ–π—Ç–µ –≤ –±—Ä–∞—É–∑–µ—Ä–µ:** [http://localhost:3000](http://localhost:3000)

### –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç

1. **–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö**: –ó–∞–≥—Ä—É–∑–∏—Ç–µ JSON —Ñ–∞–π–ª —Å–æ —Å–ª–æ–≤–∞–º–∏ (—Ñ–æ—Ä–º–∞—Ç: original_text, translation_text, transcription)
2. **–ö–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏—è**: –ù–∞–∂–º–∏—Ç–µ "Categorize All Uncategorized" - AI –æ–ø—Ä–µ–¥–µ–ª–∏—Ç —Ç–∏–ø —Å–ª–æ–≤–∞ –¥–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
3. **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ–º–ø—Ç–æ–≤**: –ù–∞–∂–º–∏—Ç–µ "Generate All Prompts" - AI —Å–æ–∑–¥–∞—Å—Ç –æ–ø–∏—Å–∞–Ω–∏—è —Å—Ü–µ–Ω –≤ —Å—Ç–∏–ª–µ —ç–º–æ–¥–∑–∏
4. **–°–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π**: –ù–∞–∂–º–∏—Ç–µ "Generate Image" - SDXL-emoji —Å–æ–∑–¥–∞—Å—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∫–∞—Ä—Ç–∏–Ω–∫–∏
5. **–ì–∞–ª–µ—Ä–µ—è**: –ü—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã, –æ—Ü–µ–Ω–∏—Ç–µ –∫–∞—á–µ—Å—Ç–≤–æ (‚úÖ/‚ùå)
6. **–≠–∫—Å–ø–æ—Ä—Ç**: –°–∫–∞—á–∞–π—Ç–µ —É–ª—É—á—à–µ–Ω–Ω—ã–π –¥–∞—Ç–∞—Å–µ—Ç —Å –ø—Ä–æ–º–ø—Ç–∞–º–∏ –∏ –∫–∞—Ä—Ç–∏–Ω–∫–∞–º–∏

**–í–∞–∂–Ω–æ**: –í—Å–µ –ø—Ä–æ–º–ø—Ç—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å "TOK emoji of" - —ç—Ç–æ –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç —Å—Ç–∏–ª—å —ç–º–æ–¥–∑–∏!

### –≠–∫–æ–Ω–æ–º–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤

–î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–∞–∫–µ—Ç–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –ø–æ N –∑–∞–ø–∏—Å–µ–π –≤–º–µ—Å—Ç–æ –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏:
- **–ö–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏—è**: –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ 10 —Å–ª–æ–≤ –∑–∞ —Ä–∞–∑
- **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ–º–ø—Ç–æ–≤**: –º–æ–∂–Ω–æ –∑–∞–ø—É—Å–∫–∞—Ç—å –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–∞–ø–∏—Å–µ–π

### –ù–∞—Å—Ç—Ä–æ–π–∫–∏

**–ú–æ–¥–µ–ª—å Gemini**: `lib/gemini.ts` - —Å—Ç—Ä–æ–∫–∞ —Å `model: 'gemini-2.5-flash-preview-05-20'`

**–ü—Ä–æ–º–ø—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏**: `app/api/categorize-vocabulary/route.ts` - –ø—Ä–æ–º–ø—Ç —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏ CONCRETE-VISUAL, ABSTRACT-SYMBOLIC –∏ —Ç.–¥.

**–®–∞–±–ª–æ–Ω –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π**: `lib/gemini.ts` - —Ñ—É–Ω–∫—Ü–∏—è `generatePrompt()`, –ø—Ä–∞–≤–∏–ª–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ–±—ä–µ–∫—Ç–æ–≤

**–ù–∞—Å—Ç—Ä–æ–π–∫–∏ SDXL-emoji**: `lib/replicateConfig.ts`
- –ú–æ–¥–µ–ª—å: `fofr/sdxl-emoji`
- –ü—Ä–µ—Ñ–∏–∫—Å –ø—Ä–æ–º–ø—Ç–∞: `A TOK emoji of` (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ!)
- –ü–∞—Ä–∞–º–µ—Ç—Ä—ã: lora_scale: 0.6, guidance_scale: 7.5, num_inference_steps: 50

## Database Migration for Vercel

After setting up your Vercel Postgres database:

1. Get your `DATABASE_URL` from the Vercel dashboard
2. Run database migrations: `npx kysely migrate up --url "$DATABASE_URL"`

## Backup Recommendations (Vercel)

- **Vercel Postgres:** It is highly recommended to enable daily snapshots for your Postgres instance through the Vercel dashboard.
- **Vercel Blob:** For critical data in Vercel Blob, consider implementing a script or strategy for periodic backups. Refer to Vercel's documentation for available options and best practices.
</file>

<file path="app/api/categorize-vocabulary/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { callOpenRouter, handleOpenRouterError } from '@/lib/openrouter';
import { languageCardRepository } from '@/lib/db/repository';
import { CategorizationResult } from '@/types';
import { handleApiRequest, validateRequestArray } from '@/lib/apiUtils';

export const maxDuration = 60; // 60 seconds timeout

interface CategorizeRequest {
  entries: Array<{
    id: number;
    original_text: string;
    translation_text: string;
    level_id: number;
  }>;
}

interface CategorizeResponse {
  results: Array<{
    id: number;
    categorization: CategorizationResult;
  }>;
  errors: Array<{
    id: number;
    error: string;
  }>;
}

function createCategorizationPrompt(entry: CategorizeRequest['entries'][0]): string {
  return `Categorize the following vocabulary word for image generation suitability.
Word: ${entry.original_text}
Translation: ${entry.translation_text}
Context: English language learning, level ${entry.level_id}

Analyze and categorize based on:
- Concrete/Abstract nature
- Visual representation potential (HIGH/MEDIUM/LOW)
- Word type (noun/verb/adjective/adverb/phrase)
- Suggest a direct, ready-to-use image prompt if the word is abstract or needs transformation.

Output JSON only, matching this exact structure:
{
  "primary_category": "CONCRETE-VISUAL" | "ABSTRACT-SYMBOLIC" | "ACTION-VISUAL" | "STATE-METAPHORICAL",
  "image_suitability": "HIGH" | "MEDIUM" | "LOW",
  "word_type": "noun" | "verb" | "adjective" | "adverb" | "phrase",
  "transformation_needed": boolean,
  "transformation_suggestion": "string", // CRITICAL: This MUST be a direct image prompt, NOT an explanation.
  "confidence": number
}

"transformation_suggestion" RULES:
- If transformation is NOT needed, leave this as an empty string "".
- If transformation IS needed, provide a concise, direct image prompt (max 4 words).
- DO NOT use phrases like "Represent with...", "Visualize as...", "Show a...".
- The suggestion itself should NOT contain the word "emoji". The system adds that context later.
- The suggestion should be a concrete noun or a person-centric action.

GOOD Example ("happiness"):
{
  ...
  "transformation_suggestion": "smiling face" // Correct: no "emoji" word.
}

BAD Example ("happiness"):
{
  ...
  "transformation_suggestion": "smiling emoji face" // WRONG! Contains the word "emoji".
}

GOOD Example ("above"):
{
  ...
  "transformation_suggestion": "person pointing up"
}

BAD Example ("above"):
{
  ...
  "transformation_suggestion": "An image showing a person pointing up" // WRONG! Conversational.
}`;
}

async function categorizeEntry(entry: CategorizeRequest['entries'][0]): Promise<CategorizationResult> {
  const prompt = createCategorizationPrompt(entry);
  
  try {
    console.log(`Sending categorization request for "${entry.original_text}"`);
    console.log('Using OpenRouter with model:', process.env.OPENROUTER_MODEL || 'google/gemini-2.5-flash-preview-05-20');
    
    const response = await callOpenRouter([
      {
        role: 'system',
        content: 'You are a helpful assistant that categorizes vocabulary words for image generation suitability. Output only valid JSON. No explanations.'
      },
      {
        role: 'user',
        content: prompt
      }
    ], {
      temperature: 0.1,
      max_tokens: 8192,
      response_format: { type: 'json_object' }
    });
    
    console.log(`OpenRouter response for "${entry.original_text}":`, response);
    
    // Parse the response
    let jsonText = response.trim();
    
    // Remove markdown code blocks if present
    if (jsonText.includes('```json')) {
      jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
    } else if (jsonText.includes('```')) {
      jsonText = jsonText.replace(/```\s*/g, '').trim();
    }
    
    // Extract JSON object if there's extra text
    const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
    jsonText = jsonMatch ? jsonMatch[0] : jsonText;
    
    console.log(`[Categorization] Attempting to parse JSON for entry ID ${entry.id}:`, jsonText);
    let categorization: CategorizationResult;
    try {
      categorization = JSON.parse(jsonText) as CategorizationResult;
    } catch (parseError) {
      console.error('JSON parse error:', parseError);
      console.error('Failed to parse text:', jsonText);
      console.error('Original response text:', response);
      throw new Error(`JSON parse error: ${parseError instanceof Error ? parseError.message : 'Unknown parse error'}`);
    }
    console.log(`[Categorization] Successfully parsed categorization for entry ID ${entry.id}:`, categorization);
    
    // Validate the response structure
    if (!categorization.primary_category || !categorization.image_suitability || categorization.word_type === undefined) {
      throw new Error('Invalid categorization response structure');
    }
    
    // Ensure boolean type for transformation_needed
    categorization.transformation_needed = Boolean(categorization.transformation_needed);
    
    // Ensure string type for transformation_suggestion
    categorization.transformation_suggestion = categorization.transformation_suggestion || '';
    
    // Ensure confidence is a number between 0 and 1
    categorization.confidence = Math.max(0, Math.min(1, Number(categorization.confidence) || 0.5));
    
    return categorization;
  } catch (error) {
    console.error(`[Categorization] Failed to categorize entry ID: ${entry.id}, Word: "${entry.original_text}". Error:`, error);
    
    // Use the OpenRouter error handler for better error messages
    const errorInfo = handleOpenRouterError(error);
    console.error('Handled error info:', errorInfo);
    throw new Error(errorInfo.message);
  }
}

export async function POST(request: NextRequest) {
  return handleApiRequest(request, async (_req, body: CategorizeRequest) => {
    // Validate request
    const validation = validateRequestArray(body.entries, 'entries');
    if (!validation.valid) {
      return NextResponse.json({ error: validation.error }, { status: validation.status });
    }
    
    if (body.entries.length > 10) {
      return NextResponse.json({ error: 'Invalid request: maximum 10 entries allowed per batch' }, { status: 400 });
    }
    
    const response: CategorizeResponse = {
      results: [],
      errors: [],
    };
    
    // Process entries in parallel
    const promises = body.entries.map(async (entry) => {
      try {
        // Update status to processing
        await languageCardRepository.update(entry.id, {
          categorizationStatus: 'processing',
        });
        
        // Categorize the entry
        const categorization = await categorizeEntry(entry);
        console.log(`Successfully categorized entry ${entry.id}:`, categorization);
        
        // Save categorization to database
        await languageCardRepository.update(entry.id, {
          categorization,
          categorizationStatus: 'completed',
        });
        
        response.results.push({
          id: entry.id,
          categorization,
        });
        console.log(`Added to results array. Current results length: ${response.results.length}`);
      } catch (error) {
        console.error(`=== ENTRY ${entry.id} ERROR ===`);
        console.error(`Failed to categorize entry ${entry.id}:`, error);
        console.error(`Entry details:`, {
          id: entry.id,
          original_text: entry.original_text,
          translation_text: entry.translation_text,
          level_id: entry.level_id
        });
        console.error('Error details:', {
          message: error instanceof Error ? error.message : String(error),
          name: error instanceof Error ? error.name : 'Unknown',
          stack: error instanceof Error ? error.stack : 'No stack',
        });
        console.error(`=== END ENTRY ${entry.id} ERROR ===`);
        
        // Update status to error
        await languageCardRepository.update(entry.id, {
          categorizationStatus: 'error',
        });
        
        response.errors.push({
          id: entry.id,
          error: `Word "${entry.original_text}": ${error instanceof Error ? error.message : 'Unknown error'}`,
        });
      }
    });
    
    await Promise.all(promises);
    
    console.log('Final response being sent:', {
      resultsCount: response.results.length,
      errorsCount: response.errors.length,
      results: response.results,
      errors: response.errors
    });
    
    return NextResponse.json(response);
  });
}
</file>

<file path="app/api/generate-image/route.ts">
import Replicate from 'replicate';
import { NextRequest, NextResponse } from 'next/server';
import { getReplicateModel, createReplicateInput } from '@/lib/replicateConfig';
import { handleApiRequest, validateRequestBody } from '@/lib/apiUtils';
import { uploadImageToSupabase, ensureEmojiImagesBucket } from '@/lib/supabaseImageStorage';

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN!,
});

export async function POST(request: NextRequest) {
  return handleApiRequest(request, async (_req, body: { prompt: string; entryId: number; englishWord: string }) => {
    const validation = validateRequestBody(body, ['prompt', 'entryId', 'englishWord']);
    if (!validation.valid) {
      return NextResponse.json({ error: validation.error }, { status: validation.status });
    }

    const { prompt, entryId } = body;

    let output;
    try {
      output = await replicate.run(
        getReplicateModel(),
        {
          input: createReplicateInput(prompt),
        }
      );
    } catch (error: any) {
      console.error('Replicate API error:', error);
      
      // Handle specific Replicate API errors
      if (error.message?.includes('Invalid token') || error.message?.includes('Unauthorized')) {
        return NextResponse.json(
          { error: 'Invalid API token. Please check your REPLICATE_API_TOKEN in .env.local' },
          { status: 401 }
        );
      }
      
      if (error.message?.includes('rate limit')) {
        return NextResponse.json(
          { error: 'Rate limit exceeded. Please try again later.' },
          { status: 429 }
        );
      }
      
      throw error; // Re-throw to let handleApiRequest handle it
    }

    console.log('Raw output from replicate.run:', output);
    console.log('Output type:', typeof output);
    console.log('Is array?', Array.isArray(output));

    // The output from replicate.run() is typically an array of FileOutput objects
    // For SDXL-emoji with num_outputs: 1, it should be an array with one FileOutput
    let imageUrl: string;
    
    if (Array.isArray(output) && output.length > 0) {
      // Get the first FileOutput object and call .url() to get the URL
      const fileOutput = output[0] as any;
      const urlResult = fileOutput.url ? fileOutput.url() : fileOutput.toString();
      imageUrl = urlResult.toString(); // Convert URL object to string
      console.log('Extracted imageUrl from FileOutput:', imageUrl);
    } else if (output && typeof output === 'object' && 'url' in output) {
      // Handle case where it might be a single FileOutput object
      const urlResult = (output as any).url();
      imageUrl = urlResult.toString(); // Convert URL object to string
      console.log('Extracted imageUrl from single FileOutput:', imageUrl);
    } else if (typeof output === 'string') {
      // Handle case where it might already be a URL string
      imageUrl = output;
      console.log('Output was already a string URL:', imageUrl);
    } else {
      console.error('Unexpected output format:', output);
      throw new Error('Unexpected output format from Replicate');
    }
    
    // Validate that we got a valid URL
    if (!imageUrl || typeof imageUrl !== 'string' || !imageUrl.startsWith('http')) {
      console.error('Invalid imageUrl received:', imageUrl);
      return NextResponse.json(
        { error: 'Failed to get a valid image URL' },
        { status: 500 }
      );
    }

    // Upload the image to Supabase Storage
    try {
      // Ensure bucket exists
      await ensureEmojiImagesBucket();
      
      // 1. Fetch the image content from the Replicate URL
      const imageResponse = await fetch(imageUrl);
      if (!imageResponse.ok) {
        throw new Error(`Failed to fetch image from Replicate: ${imageResponse.statusText}`);
      }
      const imageBuffer = Buffer.from(await imageResponse.arrayBuffer());
      const contentType = imageResponse.headers.get('content-type') || 'image/png';

      // 2. Upload to Supabase Storage
      const uploadResult = await uploadImageToSupabase(imageBuffer, entryId, contentType);

      const generatedAt = new Date().toISOString();

      return NextResponse.json({
        imageUrl: uploadResult.imageUrl, // This is now the Supabase public URL
        originalUrl: imageUrl, // Still useful to keep the Replicate URL if needed
        status: 'completed',
        generatedAt: generatedAt,
      });
    } catch (uploadError) {
      console.error('Error uploading image to Supabase Storage:', uploadError);
      // If upload fails, still return the original URL
      return NextResponse.json({ 
        imageUrl,
        status: 'completed',
        uploadError: 'Failed to upload image to Supabase Storage, using remote URL',
      });
    }
  });
}
</file>

<file path="app/page.tsx">
'use client';

import { useState } from 'react';
import { useAppStore } from '@/store/useAppStore';
import FileUpload from '@/components/FileUpload';
import DataTable from '@/components/DataTable';
import Gallery from '@/components/Gallery';
import ASCIILogo from '@/components/ASCIILogo';
import QueueStatus from '@/components/QueueStatus';
import { FileText, Image } from 'lucide-react';

export default function Home() {
  const { entries, activeTab, setActiveTab, isInitialized } = useAppStore();
  const hasData = entries.length > 0;

  // Show loading state if store isn't initialized yet
  if (!isInitialized) {
    return (
      <div className="min-h-screen bg-black flex items-center justify-center">
        <div className="text-center">
          <div className="mb-4">
            <ASCIILogo />
          </div>
          <div className="text-gray-400">Loading...</div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-black">
      <main className="px-4 sm:px-6 lg:px-8 py-8">
        <div className="mb-8 flex justify-center">
          <ASCIILogo />
        </div>
        
        {!hasData ? (
          <FileUpload />
        ) : (
          <>
            <div className="mb-6 bg-gray-900 rounded-lg shadow-sm border border-gray-800">
              <div className="border-b border-gray-800">
                <nav className="flex -mb-px">
                  <button
                    onClick={() => setActiveTab('table')}
                    className={`
                      group inline-flex items-center px-6 py-4 text-sm font-medium transition-colors
                      ${activeTab === 'table' ? 'tab-active' : 'tab-inactive'}
                    `}
                  >
                    <FileText className="mr-2 h-4 w-4" />
                    [TABLE]
                  </button>
                  <button
                    onClick={() => setActiveTab('gallery')}
                    className={`
                      group inline-flex items-center px-6 py-4 text-sm font-medium transition-colors
                      ${activeTab === 'gallery' ? 'tab-active' : 'tab-inactive'}
                    `}
                  >
                    <Image className="mr-2 h-4 w-4" />
                    [GALLERY]
                  </button>
                </nav>
              </div>
              
              <div className="p-6">
                {activeTab === 'table' ? <DataTable /> : <Gallery />}
              </div>
            </div>
          </>
        )}
      </main>
      
      {/* Queue Status - shows when there are items in queue */}
      <QueueStatus />
    </div>
  );
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'replicate.delivery',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'pbxt.replicate.delivery',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: '*.blob.vercel-storage.com',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: '*.supabase.co',
        pathname: '/storage/v1/object/public/**',
      },
    ],
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
  // Disable the Next.js dev indicator completely
  devIndicators: false,
  // Fix file watching issues (only when not using Turbopack)
  webpack: (config, { dev, isServer }) => {
    // Check if Turbopack is being used
    const isTurbopack = process.env.TURBOPACK === '1' || process.argv.includes('--turbopack');
    
    if (dev && !isServer && !isTurbopack) {
      config.watchOptions = {
        poll: 1000, // Check for changes every second
        aggregateTimeout: 300, // Delay rebuild after change detection
        ignored: [
          '**/node_modules',
          '**/.next',
          '**/.git',
          '**/public/images', // Also ignore generated images
        ],
      };
    }
    return config;
  },
};

export default nextConfig;
</file>

<file path="app/api/generate-prompt/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getGeminiModel, formatSinglePrompt } from '@/lib/gemini';
import { getPromptOverride } from '@/lib/promptOverrides';
import { handleApiRequest, validateRequestBody } from '@/lib/apiUtils';
import { languageCardRepository } from '@/lib/db/repository';

export async function POST(request: NextRequest) {
  return handleApiRequest(request, async (_req, body: { entryId: number; english: string; russian: string; transcription: string }) => {
    const validation = validateRequestBody(body, ['entryId', 'english', 'russian', 'transcription']);
    if (!validation.valid) {
      return NextResponse.json({ error: validation.error }, { status: validation.status });
    }

    const { entryId, english, russian, transcription } = body;

    // Check for prompt override first
    const override = getPromptOverride(english);
    if (override) {
      console.log(`Using prompt override for "${english}": "${override}"`);
      return NextResponse.json({ prompt: override });
    }

    // Check for existing transformation suggestion from categorization
    const wordEntry = await languageCardRepository.findById(entryId);
    if (wordEntry?.categorization) {
      const { transformation_needed, transformation_suggestion } = wordEntry.categorization;
      if (transformation_needed && transformation_suggestion && transformation_suggestion.trim() !== '') {
        console.log(`Using categorization transformation suggestion for "${english}": "${transformation_suggestion}"`);
        return NextResponse.json({ prompt: transformation_suggestion });
      }
    }

    // Fall back to AI generation
    const model = getGeminiModel();
    const prompt = formatSinglePrompt(english, russian, transcription);

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    // Parse the response to extract just the description
    let finalPrompt = text;
    try {
      // Remove any markdown code blocks if present
      const cleanedText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      const parsed = JSON.parse(cleanedText);
      finalPrompt = parsed.prompt || parsed.single_object || text;
    } catch {
      // If parsing fails, use the original text
      console.log('Failed to parse AI response as JSON, using raw text:', text);
    }

    return NextResponse.json({ prompt: finalPrompt });
  });
}
</file>

<file path="package.json">
{
  "name": "sdxl-emoji-pipeline",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "@supabase/supabase-js": "^2.49.10",
    "@tailwindcss/postcss": "^4.1.7",
    "@tanstack/react-table": "^8.21.3",
    "@vercel/blob": "^1.1.1",
    "dotenv": "^16.5.0",
    "js-yaml": "^4.1.0",
    "kysely": "^0.28.2",
    "lucide-react": "^0.511.0",
    "next": "15.3.2",
    "postcss": "^8.5.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-dropzone": "^14.3.8",
    "react-hot-toast": "^2.5.2",
    "replicate": "^1.0.1",
    "tailwindcss": "^4.1.7",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@types/js-yaml": "^4.0.9",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9.27.0",
    "eslint-config-next": "^15.3.3",
    "supabase": "^2.24.3",
    "typescript": "^5"
  }
}
</file>

<file path="app/api/generate-prompts-batch/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import {
  callOpenRouter,
  formatOpenRouterBatchPromptMessages,
  BatchPromptEntry,
} from '@/lib/openrouter';
import { getPromptOverride } from '@/lib/promptOverrides';
import { handleApiRequest, validateRequestArray } from '@/lib/apiUtils';

export async function POST(request: NextRequest) {
  return handleApiRequest(request, async (_req, body: { entries: BatchPromptEntry[] }) => {
    const validation = validateRequestArray(body.entries, 'entries');
    if (!validation.valid) {
      return NextResponse.json({ error: validation.error }, { status: validation.status });
    }

    const { entries } = body;

    // Check for overrides, separating entries
    const finalResults: { id: number; prompt: string }[] = [];
    const entriesToGenerate: BatchPromptEntry[] = [];

    for (const entry of entries) {
      // Priority 1: Check for YAML override
      const override = getPromptOverride(entry.english);
      if (override) {
        console.log(`Using prompt override for "${entry.english}": "${override}"`);
        finalResults.push({ id: entry.id, prompt: override });
        continue;
      }

      // Priority 2: Need AI generation (always generate fresh prompts unless YAML override exists)
      entriesToGenerate.push(entry);
    }

    let aiGeneratedResults: { id: number; prompt: string }[] = [];

    // Only call AI for entries without overrides
    if (entriesToGenerate.length > 0) {
      const messages = formatOpenRouterBatchPromptMessages(entriesToGenerate);
      const rawResponseContent = await callOpenRouter(messages);

      console.log('Raw OpenRouter response content:', rawResponseContent);

      // The content from callOpenRouter should be a stringified JSON if response_format is json_object
      const responseText = typeof rawResponseContent === 'string' ? rawResponseContent : JSON.stringify(rawResponseContent);

      let prompts;
      try {
        // Remove any markdown code blocks if present (good safeguard)
        const cleanedText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        prompts = JSON.parse(cleanedText);
      } catch (parseError) {
        console.error('Failed to parse OpenRouter response:', parseError);
        console.error('Response text from AI:', responseText);
        return NextResponse.json(
          { error: 'Failed to parse AI response' },
          { status: 500 }
        );
      }

      if (!Array.isArray(prompts)) {
        console.error('Invalid response format from AI. Expected array, got:', prompts);
        return NextResponse.json(
          { error: 'Invalid response format from AI' },
          { status: 500 }
        );
      }

      const promptMap = new Map(prompts.map((p: { id: number; prompt?: string; single_object?: string }) => [
        p.id, 
        p.prompt || p.single_object || 'Failed to generate prompt'
      ]));

      aiGeneratedResults = entriesToGenerate.map(entry => ({
        id: entry.id,
        prompt: promptMap.get(entry.id) || 'Failed to generate prompt',
      }));
    }

    // Combine all results (overrides and AI-generated), maintaining original order
    const allResults = [...finalResults, ...aiGeneratedResults];
    const sortedResults = allResults.sort((a, b) => a.id - b.id);

    return NextResponse.json({ prompts: sortedResults });
  });
}
</file>

<file path="lib/imageQueue.ts">
import Replicate from 'replicate';
import { getReplicateModel, createReplicateInput } from './replicateConfig';
import { languageCardRepository } from './db/repository';
import { uploadImageToSupabase, ensureEmojiImagesBucket } from './supabaseImageStorage';

if (!process.env.REPLICATE_API_TOKEN) {
  console.error('REPLICATE_API_TOKEN is not set in environment variables');
  throw new Error('REPLICATE_API_TOKEN is required but not set');
}

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN!,
});

interface ReplicateOutputItem {
  url?: () => { toString: () => string };
  toString: () => string;
}

interface NotifyCompletionResult {
  imageUrl: string;
  originalUrl: string;
  generatedAt: string;
}

interface QueueItem {
  id: string;
  entryId: number;
  englishWord: string;
  prompt: string;
  predictionId?: string;
  status: 'pending' | 'processing' | 'completed' | 'error';
  retries: number;
  createdAt: Date;
}

class ImageGenerationQueue {
  private queue: QueueItem[] = [];
  private processing = false;
  private maxRetries = 3;
  private concurrentLimit = 1; // Process one at a time to avoid rate limits
  private processingCount = 0;

  // Add item to queue
  async addToQueue(entryId: number, englishWord: string, prompt: string): Promise<string> {
    // Check if this entry is already in queue
    const existingItem = this.queue.find(item => item.entryId === entryId);
    if (existingItem) {
      console.log(`Entry ${entryId} (${englishWord}) already in queue with status: ${existingItem.status}`);
      return existingItem.id;
    }

    const queueId = `queue-${Date.now()}-${entryId}`;
    const item: QueueItem = {
      id: queueId,
      entryId,
      englishWord,
      prompt,
      status: 'pending',
      retries: 0,
      createdAt: new Date(),
    };

    this.queue.push(item);
    console.log(`Added to queue: ${englishWord} (${queueId}) - Total queue: ${this.queue.length}`);
    
    // Start processing if not already running
    if (!this.processing) {
      this.startProcessing();
    }

    return queueId;
  }

  // Start processing queue
  private async startProcessing() {
    if (this.processing) {
      console.log('Processing already running, skipping...');
      return;
    }
    
    this.processing = true;
    console.log(`Starting image queue processing... Total items: ${this.queue.length}`);

    while (this.queue.length > 0) {
      const pendingItems = this.queue.filter(item => item.status === 'pending');
      console.log(`Queue status: Total=${this.queue.length}, Pending=${pendingItems.length}`);
      
      const item = pendingItems[0]; // Get first pending item
      if (!item) {
        console.log('No pending items, waiting...');
        await new Promise(resolve => setTimeout(resolve, 1000));
        continue;
      }

      console.log(`Processing next item: ${item.englishWord} (${item.id})`);
      
      // Process one item at a time (sequential processing)
      await this.processItem(item);
      
      // Small delay between items to avoid overwhelming the API
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    this.processing = false;
    console.log('Queue processing finished - no more items');
  }

  // Process individual item
  private async processItem(item: QueueItem) {
    while (item.status === 'pending' && item.retries < this.maxRetries) {
      try {
        console.log(`Processing: ${item.englishWord} (${item.id}) - Attempt ${item.retries + 1}`);
        item.status = 'processing';

        // Create prediction (async) using centralized config
        const prediction = await replicate.predictions.create({
          version: getReplicateModel(),
          input: createReplicateInput(item.prompt),
        });

        item.predictionId = prediction.id;
        console.log(`Created prediction: ${prediction.id} for ${item.englishWord}`);

        // Wait for completion
        const result = await replicate.wait(prediction);
        
        if (result.status === 'succeeded' && result.output) {
          await this.handleSuccess(item, result.output as ReplicateOutputItem[]);
          return; // Success - exit the retry loop
        } else {
          throw new Error(`Prediction failed: ${result.error || 'Unknown error'}`);
        }

      } catch (error) {
        console.error(`Attempt ${item.retries + 1} failed for ${item.englishWord}:`, error);
        item.retries++;
        
        if (item.retries < this.maxRetries) {
          console.log(`Retrying ${item.englishWord} (attempt ${item.retries + 1}/${this.maxRetries}) after delay`);
          item.status = 'pending';
          // Add delay before retry (exponential backoff)
          await new Promise(resolve => setTimeout(resolve, 5000 * item.retries));
        } else {
          console.error(`Max retries reached for ${item.englishWord} (${item.id})`);
          item.status = 'error';
          
          // Update database on final failure
          try {
            await languageCardRepository.update(item.entryId, {
              imageStatus: 'error',
              replicateId: item.predictionId,
            });
            console.log(`[DB] Successfully updated entry ID ${item.entryId} status to 'error'.`);
          } catch (dbError) {
            console.error(`[DB] CRITICAL: Failed to update database to 'error' status for entry ID ${item.entryId}.`, dbError);
          }

          // Notify error
          this.notifyError(item, (error as Error).message || 'Generation failed');
          
          // Remove from queue
          this.removeFromQueue(item.id);
          return; // Exit retry loop
        }
      }
    }
  }

  // Handle successful generation
  private async handleSuccess(item: QueueItem, output: ReplicateOutputItem[]) {
    try {
      console.log(`Success: ${item.englishWord} (${item.id})`);
      
      // Get image URL from output
      let imageUrl: string;
      if (Array.isArray(output) && output.length > 0) {
        const fileOutput = output[0];
        imageUrl = fileOutput.url ? fileOutput.url().toString() : fileOutput.toString();
      } else {
        throw new Error('Invalid output format');
      }

      // Download and upload image with resizing to Supabase Storage
      const uploadResult = await this.downloadAndUploadToSupabase(imageUrl, item.entryId);
      
      item.status = 'completed';
      
      // Update the database with the new image URL and status
      const generatedAt = new Date().toISOString();
      try {
        // First, get the current entry to check if it had a bad QA score
        const currentEntry = await languageCardRepository.findById(item.entryId);
        const updateData = {
          imageUrl: uploadResult.imageUrl,
          imageStatus: 'completed' as const,
          replicateId: item.predictionId,
          imageGeneratedAt: generatedAt,
          ...(currentEntry && currentEntry.qaScore === 'bad' ? { qaScore: null } : {})
        };
        
        // If this entry had a bad QA score, reset it to null so it can be re-evaluated
        if (currentEntry && currentEntry.qaScore === 'bad') {
          console.log(`[DB] Resetting QA score for entry ID ${item.entryId} (was 'bad')`);
        }
        
        await languageCardRepository.update(item.entryId, updateData);
        console.log(`[DB] Successfully updated entry ID ${item.entryId} with new image.`);
      } catch (dbError) {
        console.error(`[DB] CRITICAL: Failed to update database for entry ID ${item.entryId} after successful image generation and upload.`, dbError);
      }

      // Notify completion via callback or event
      this.notifyCompletion(item, {
        imageUrl: uploadResult.imageUrl,
        originalUrl: uploadResult.originalUrl,
        generatedAt: generatedAt,
      });

      // Remove from queue
      this.removeFromQueue(item.id);

    } catch (error) {
      console.error(`Error processing success for ${item.englishWord}:`, error);
      throw error; // Re-throw to be handled by processItem
    }
  }


  // Download and upload image to Supabase Storage with resizing
  private async downloadAndUploadToSupabase(imageUrl: string, entryId: number) {
    console.log('Downloading and uploading image from:', imageUrl);
    
    // Ensure bucket exists
    await ensureEmojiImagesBucket();
    
    // Fetch the image
    const response = await fetch(imageUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch image: ${response.statusText}`);
    }
    
    const imageBuffer = await response.arrayBuffer();
    let buffer = Buffer.from(imageBuffer);
    
    // Skip resizing for now to reduce deployment size
    // Images will be stored as-is from Replicate
    console.log(`Uploading image ${entryId} without resizing...`);
    
    // Upload to Supabase Storage
    const uploadResult = await uploadImageToSupabase(buffer, entryId, 'image/png');
    
    return {
      imageUrl: uploadResult.imageUrl,
      originalUrl: imageUrl,
      filename: uploadResult.filename
    };
  }

  // Remove item from queue
  private removeFromQueue(queueId: string) {
    const index = this.queue.findIndex(item => item.id === queueId);
    if (index > -1) {
      const item = this.queue[index];
      this.queue.splice(index, 1);
      console.log(`Removed from queue: ${item.englishWord} (${queueId}) - Remaining: ${this.queue.length}`);
    } else {
      console.log(`Item not found in queue for removal: ${queueId}`);
    }
  }

  // Get queue status
  getQueueStatus() {
    const status = {
      total: this.queue.length,
      pending: this.queue.filter(item => item.status === 'pending').length,
      processing: this.queue.filter(item => item.status === 'processing').length,
      completed: this.queue.filter(item => item.status === 'completed').length,
      errors: this.queue.filter(item => item.status === 'error').length,
      isProcessing: this.processing,
    };
    
    return status;
  }

  // Get queue items
  getQueueItems() {
    return this.queue.map(item => ({
      id: item.id,
      entryId: item.entryId,
      englishWord: item.englishWord,
      status: item.status,
      retries: item.retries,
      createdAt: item.createdAt,
      predictionId: item.predictionId,
    }));
  }

  // Clear the entire queue
  clearQueue() {
    const clearedCount = this.queue.length;
    this.queue = [];
    this.processing = false;
    console.log(`Cleared ${clearedCount} items from image generation queue`);
    return clearedCount;
  }

  // Callback methods (to be overridden)
  protected notifyCompletion(item: QueueItem, _result: NotifyCompletionResult) {
    // Override this method to handle completion
    console.log(`‚úÖ Completed: ${item.englishWord}`);
  }

  protected notifyError(item: QueueItem, error: string) {
    // Override this method to handle errors
    console.log(`‚ùå Error: ${item.englishWord} - ${error}`);
  }

  protected notifyProgress(item: QueueItem, status: string) {
    // Override this method to handle progress updates
    console.log(`üîÑ Progress: ${item.englishWord} - ${status}`);
  }
}

// Export singleton instance
export const imageQueue = new ImageGenerationQueue();
export type { QueueItem };
</file>

<file path="components/DataTable.tsx">
'use client';

import { useState, useMemo } from 'react';
import {
  useReactTable,
  getCoreRowModel,
  getSortedRowModel,
  getPaginationRowModel,
  flexRender,
  ColumnDef,
  SortingState,
} from '@tanstack/react-table';
import { useAppStore } from '@/store/useAppStore';
import { WordEntry } from '@/types';
import { ChevronUp, ChevronDown, Search, Filter, Sparkles, ImageIcon, Edit2, Save, X, RefreshCcw } from 'lucide-react';
import toast from 'react-hot-toast';
import { activityManager } from './ActivityLog';
import { BatchActionMenu } from './BatchActionMenu';
import {
  generatePromptService,
  queueImageService,
  generatePromptsBatchService,
  categorizeVocabularyService,
  batchGenerateImagesService,
  clearQueueService,
} from '@/lib/apiClient';
import { processBatch } from '@/lib/batchUtils';

export default function DataTable() {
  const {
    entries,
    updateEntry,
    currentPage,
    setCurrentPage,
    itemsPerPage,
    searchQuery,
    setSearchQuery,
    getFilteredEntries,
  } = useAppStore();

  const [sorting, setSorting] = useState<SortingState>([]);
  const [editingId, setEditingId] = useState<number | null>(null);
  const [editingPrompt, setEditingPrompt] = useState<string>('');
  const [imageFilter, setImageFilter] = useState<'all' | 'with' | 'without' | 'bad'>('all');
  const [promptFilter, setPromptFilter] = useState<'all' | 'with' | 'without'>('all');
  const [categorizationFilter, setCategorizationFilter] = useState<'all' | 'uncategorized' | 'categorized'>('all');
  const [suitabilityFilter, setSuitabilityFilter] = useState<'all' | 'HIGH' | 'MEDIUM' | 'LOW'>('all');
  const [customCategorizeCount, setCustomCategorizeCount] = useState<string>('10');
  const [customBatchGenerateCount, setCustomBatchGenerateCount] = useState<string>('10');
  const [customImageBatchCount, setCustomImageBatchCount] = useState<string>('20');

  const filteredData = useMemo(() => {
    let data = getFilteredEntries();
    
    // Apply prompt filter
    if (promptFilter === 'with') {
      data = data.filter(entry => entry.prompt && entry.prompt.trim() !== '');
    } else if (promptFilter === 'without') {
      data = data.filter(entry => !entry.prompt || entry.prompt.trim() === '');
    }
    
    // Apply image filter
    if (imageFilter === 'with') {
      data = data.filter(entry => entry.imageUrl && entry.imageStatus === 'completed');
    } else if (imageFilter === 'without') {
      data = data.filter(entry => !entry.imageUrl || entry.imageStatus !== 'completed');
    } else if (imageFilter === 'bad') {
      data = data.filter(entry => entry.qaScore === 'bad');
    }
    
    // Apply categorization filter (NEW)
    if (categorizationFilter === 'uncategorized') {
      // Show entries that are not successfully categorized
      data = data.filter(entry =>
        !entry.categorization || entry.categorizationStatus !== 'completed'
      );
    } else if (categorizationFilter === 'categorized') {
      // Show entries that are successfully categorized
      data = data.filter(entry =>
        entry.categorization && entry.categorizationStatus === 'completed'
      );
    }
    
    // Apply suitability filter
    if (suitabilityFilter !== 'all') {
      data = data.filter(entry =>
        entry.categorization?.image_suitability === suitabilityFilter
      );
    }
    
    return data;
  }, [getFilteredEntries, entries, imageFilter, promptFilter, categorizationFilter, suitabilityFilter]);


  const handleGeneratePrompt = async (entry: WordEntry) => {
    const operationKey = `prompt-${entry.id}`;
    updateEntry(entry.id, { promptStatus: 'generating' });
    activityManager.addActivity('loading', `Generating prompt for "${entry.original_text}"`, undefined, operationKey);
    
    const result = await generatePromptService({
      entryId: entry.id,
      english: entry.original_text,
      russian: entry.translation_text,
      transcription: entry.transcription,
    });

    if (result.data) {
      updateEntry(entry.id, { prompt: result.data.prompt, promptStatus: 'completed' });
      activityManager.addActivity('success', `Generated prompt for "${entry.original_text}"`, undefined, operationKey);
    } else {
      updateEntry(entry.id, { promptStatus: 'error' });
      activityManager.addActivity('error', `Failed to generate prompt for "${entry.original_text}"`, result.error || 'Unknown error', operationKey);
    }
  };

  const handleGenerateImage = async (entry: WordEntry) => {
    if (!entry.prompt) {
      toast.error(`No prompt available for "${entry.original_text}". Generate prompt first.`);
      return;
    }

    const operationKey = `image-${entry.id}`;
    updateEntry(entry.id, { imageStatus: 'processing' });
    activityManager.addActivity('loading', `Processing image for "${entry.original_text}"`, undefined, operationKey);
    
    const result = await queueImageService({
      action: 'add',
      entryId: entry.id,
      englishWord: entry.original_text,
      prompt: entry.prompt,
    });

    if (result.data && result.data.status === 'completed' && result.data.imageUrl) {
      updateEntry(entry.id, { 
        imageUrl: result.data.imageUrl, 
        imageStatus: 'completed',
        imageGeneratedAt: result.data.generatedAt 
      });
      activityManager.addActivity('success', `Image generated for "${entry.original_text}"`, undefined, operationKey);
    } else {
      updateEntry(entry.id, { imageStatus: 'error' });
      activityManager.addActivity('error', `Failed to generate image for "${entry.original_text}"`, result.error || 'Failed to generate image', operationKey);
    }
  };

  const handleEditPrompt = (entry: WordEntry) => {
    setEditingId(entry.id);
    setEditingPrompt(entry.prompt || '');
  };

  const handleSavePrompt = (id: number) => {
    console.log('Saving prompt:', { id, prompt: editingPrompt });
    updateEntry(id, { prompt: editingPrompt, promptStatus: 'completed' });
    setEditingId(null);
    setEditingPrompt('');
    toast.success('Prompt saved');
  };

  const handleCancelEdit = () => {
    setEditingId(null);
    setEditingPrompt('');
  };

  const handleBatchGeneratePrompts = async (count: number) => {
    // Get entries without prompts
    const entriesWithoutPrompts = filteredData
      .filter(entry => !entry.prompt || entry.prompt.trim() === '')
      .slice(0, count);
    
    if (entriesWithoutPrompts.length === 0) {
      toast.error('No entries without prompts found');
      return;
    }

    const result = await processBatch({
      itemsToProcess: entriesWithoutPrompts,
      batchSize: entriesWithoutPrompts.length, // Process all at once for prompts
      delayBetweenBatchesMs: 0,
      operationName: 'Batch Prompt Generation',
      getBatchPayload: (batch) => ({
        entries: batch.map(entry => ({
          id: entry.id,
          english: entry.original_text,
          russian: entry.translation_text,
          transcription: entry.transcription,
        })),
      }),
      batchApiService: generatePromptsBatchService,
      getSuccessItems: (responseData, batchItems) => responseData.prompts || [],
      getErrorItems: (responseData) => [], // generatePromptsBatchService doesn't return separate errors array
      processItemSuccess: (result, originalEntry) => {
        updateEntry(result.id, {
          prompt: result.prompt,
          promptStatus: result.prompt === 'Failed to generate prompt' ? 'error' : 'completed',
        });
      },
      processItemError: (error, originalEntry) => {
        if (originalEntry) {
          updateEntry(originalEntry.id, { promptStatus: 'error' });
        }
      },
      onStartProcessingItem: (entry) => {
        updateEntry(entry.id, { promptStatus: 'generating' });
      },
    });

    toast.success(`Generated ${result.totalSuccess} prompts`);
  };

  const handleBatchCategorize = async (count: number) => {
    // Get entries without categorization
    const entriesWithoutCategorization = filteredData
      .filter(entry => !entry.categorization || entry.categorizationStatus !== 'completed')
      .slice(0, count);
    
    if (entriesWithoutCategorization.length === 0) {
      toast.error('No entries without categorization found');
      return;
    }

    const result = await processBatch({
      itemsToProcess: entriesWithoutCategorization,
      batchSize: 10, // API limit
      delayBetweenBatchesMs: 0,
      operationName: 'Batch Categorization (Selected)',
      getBatchPayload: (batch) => ({
        entries: batch.map(entry => ({
          id: entry.id,
          original_text: entry.original_text,
          translation_text: entry.translation_text,
          level_id: entry.level_id,
        })),
      }),
      batchApiService: categorizeVocabularyService,
      getSuccessItems: (responseData, batchItems) => responseData.results || [],
      getErrorItems: (responseData) => responseData.errors || [],
      processItemSuccess: (result, originalEntry) => {
        updateEntry(result.id, {
          categorization: result.categorization,
          categorizationStatus: 'completed',
        });
      },
      processItemError: (error, originalEntry) => {
        if (originalEntry) {
          updateEntry(originalEntry.id, { categorizationStatus: 'error' });
        }
      },
      onStartProcessingItem: (entry) => {
        updateEntry(entry.id, { categorizationStatus: 'processing' });
      },
    });

    toast.success(`Categorized ${result.totalSuccess} words`);
  };

  const handleCustomBatchCategorize = async (count: number) => {
    handleBatchCategorize(count);
  };

  const handleCustomBatchGeneratePrompts = async (count: number) => {
    handleBatchGeneratePrompts(count);
  };

  const startBatchImageGeneration = async (input: number | WordEntry[]) => {
    let itemsToProcess: WordEntry[];
    
    if (typeof input === 'number') {
      // Filter for entries that are eligible for image generation, excluding already queued/processing items
      itemsToProcess = filteredData
        .filter(entry => 
          entry.prompt && 
          entry.prompt.trim() !== '' && 
          entry.imageStatus !== 'queued' && 
          entry.imageStatus !== 'processing' && 
          (!entry.imageUrl || entry.imageStatus !== 'completed') && !entry.qaScore
        )
        .slice(0, input);
    } else {
      // Input is already a pre-filtered array
      itemsToProcess = input;
    }

    if (itemsToProcess.length === 0) {
      toast.error('No eligible entries found for image generation.');
      return;
    }

    const result = await processBatch({
      itemsToProcess,
      batchSize: 20, // Number of WordEntry items to group into a single call to /api/generate-images-batch
      delayBetweenBatchesMs: 300,
      operationName: 'Batch Image Enqueuing',
      getBatchPayload: (batch) => ({
        entries: batch.map(entry => ({
          entryId: entry.id,
          prompt: entry.prompt!,
          englishWord: entry.original_text
        }))
      }),
      batchApiService: batchGenerateImagesService,
      getSuccessItems: (responseData, batchItems) => {
        if (!responseData.success) return [];
        const errorEntryIds = new Set(responseData.errors?.map((e: any) => e.entryId) || []);
        return batchItems.filter(item => !errorEntryIds.has(item.id)).map(item => ({ 
          id: item.id, 
          serverMessage: responseData.message 
        }));
      },
      getErrorItems: (responseData) => responseData.errors || [],
      processItemSuccess: (result, originalEntry) => {
        // Item was successfully queued by the server as part of a batch API call.
        // Status already updated to 'queued' by onStartProcessingItem.
        // activityManager.addActivity('info', `Image for "${originalEntry.original_text}" (ID: ${originalEntry.id}) added to generation queue.`);
      },
      processItemError: (itemError, originalEntry) => {
        if (originalEntry) {
          updateEntry(originalEntry.id, { imageStatus: 'error' });
          activityManager.addActivity('error', `Failed to queue image for "${originalEntry.original_text}" (ID: ${originalEntry.id})`, itemError.error);
        } else if ((itemError as any).entryId) {
          activityManager.addActivity('error', `Failed to queue image for entry ID ${(itemError as any).entryId}`, itemError.error);
        } else {
          activityManager.addActivity('error', 'An item failed to queue for image generation', itemError.error);
        }
      },
      onStartProcessingItem: (entry) => {
        updateEntry(entry.id, { imageStatus: 'queued' });
      },
    });

    activityManager.addActivity('info', `Batch image enqueuing process initiated. ${result.totalSuccess} items acknowledged by server, ${result.totalFailed} items had enqueuing issues. Monitor queue status for generation progress.`);
  };

  const handleCustomBatchGenerateImages = async (count: number) => {
    // Get eligible entries once, excluding already queued/processing items
    const eligibleEntries = filteredData.filter(entry => 
      entry.prompt && 
      entry.prompt.trim() !== '' && 
      entry.imageStatus !== 'queued' && 
      entry.imageStatus !== 'processing' && 
      (!entry.imageUrl || entry.imageStatus !== 'completed') && !entry.qaScore
    );
    
    if (eligibleEntries.length === 0) {
      toast.error('No eligible entries found for image generation.');
      return;
    }
    
    const itemsForThisRun = eligibleEntries.slice(0, count);
    await startBatchImageGeneration(itemsForThisRun);
  };

  const handleBatchGenerateAllEligibleImages = async () => {
    const eligibleEntries = filteredData.filter(entry => 
      entry.prompt && 
      entry.prompt.trim() !== '' && 
      entry.imageStatus !== 'queued' && 
      entry.imageStatus !== 'processing' && 
      (!entry.imageUrl || entry.imageStatus !== 'completed') && !entry.qaScore
    );
    
    if (eligibleEntries.length === 0) {
      toast.error('No eligible entries found for image generation.');
      return;
    }
    
    await startBatchImageGeneration(eligibleEntries);
  };

  const handleBatchRegenerateBadImages = async () => {
    // Get all entries from the store to ensure we find all bad entries, not just filtered ones.
    const allEntries = useAppStore.getState().entries;
    const badEntriesWithPrompts = allEntries.filter(
      entry => entry.qaScore === 'bad' && 
      entry.prompt && 
      entry.prompt.trim() !== ''
    );

    if (badEntriesWithPrompts.length === 0) {
      toast.error('No "bad" entries with prompts found to regenerate.');
      return;
    }

    activityManager.addActivity('info', `Starting image regeneration for ${badEntriesWithPrompts.length} bad entries...`);

    // Process in chunks to avoid overwhelming the system
    const CHUNK_SIZE = 500;
    let processed = 0;
    
    while (processed < badEntriesWithPrompts.length) {
      const chunk = badEntriesWithPrompts.slice(processed, processed + CHUNK_SIZE);
      activityManager.addActivity('info', `Queueing batch ${Math.floor(processed / CHUNK_SIZE) + 1} (${chunk.length} images)...`);
      
      await startBatchImageGeneration(chunk);
      processed += chunk.length;
      
      // Add a small delay between chunks
      if (processed < badEntriesWithPrompts.length) {
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    activityManager.addActivity('success', `All ${badEntriesWithPrompts.length} bad images have been queued for regeneration!`);
    toast.success(`Queued all ${badEntriesWithPrompts.length} bad images for regeneration!`);
  };

  const handleBatchRefreshBadPrompts = async () => {
    // Filter entries with bad QA score
    const badEntries = filteredData.filter(entry => entry.qaScore === 'bad');
    
    if (badEntries.length === 0) {
      toast.error('No bad entries found');
      return;
    }

    activityManager.addActivity('info', `Starting batch refresh for ${badEntries.length} bad entries...`);

    const result = await processBatch({
      itemsToProcess: badEntries,
      batchSize: badEntries.length, // Process all at once for prompts
      delayBetweenBatchesMs: 0,
      operationName: 'Batch Refresh Bad Prompts',
      getBatchPayload: (batch) => ({
        entries: batch.map(entry => ({
          id: entry.id,
          english: entry.original_text,
          russian: entry.translation_text,
          transcription: entry.transcription,
        })),
      }),
      batchApiService: generatePromptsBatchService,
      getSuccessItems: (responseData, batchItems) => responseData.prompts || [],
      getErrorItems: (responseData) => [], // generatePromptsBatchService doesn't return separate errors array
      processItemSuccess: (result, originalEntry) => {
        updateEntry(result.id, {
          prompt: result.prompt,
          promptStatus: result.prompt === 'Failed to generate prompt' ? 'error' : 'completed',
          qaScore: null,          // Reset QA score
          imageUrl: null,         // Remove old image URL
          imageStatus: 'none'     // Reset image status for new generation
        });
        activityManager.addActivity('success', `Refreshed prompt for "${originalEntry.original_text}"`);
      },
      processItemError: (error, originalEntry) => {
        if (originalEntry) {
          updateEntry(originalEntry.id, { promptStatus: 'error' });
          activityManager.addActivity('error', `Failed to refresh prompt for "${originalEntry.original_text}"`);
        }
      },
      onStartProcessingItem: (entry) => {
        updateEntry(entry.id, { promptStatus: 'generating' });
      },
    });

    const message = `Refreshed ${result.totalSuccess} prompts. ${result.totalFailed > 0 ? `${result.totalFailed} failed.` : ''}`;
    activityManager.addActivity('info', message);
    toast.success(message);
  };

  const handleClearQueue = async () => {
    if (!confirm('Are you sure you want to clear the entire image generation queue? This will remove all pending and processing items.')) {
      return;
    }

    try {
      activityManager.addActivity('info', 'Clearing image generation queue...');
      const result = await clearQueueService();
      
      if (result.data) {
        activityManager.addActivity('success', `Cleared ${result.data.clearedCount} items from the queue`);
        toast.success(`Cleared ${result.data.clearedCount} items from the queue`);
      } else {
        activityManager.addActivity('error', `Failed to clear queue: ${result.error}`);
        toast.error(`Failed to clear queue: ${result.error}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      activityManager.addActivity('error', `Error clearing queue: ${errorMessage}`);
      toast.error(`Error clearing queue: ${errorMessage}`);
    }
  };

  const handleCleanupDescriptivePrompts = async () => {
    activityManager.addActivity('info', 'Searching for descriptive prompts to clean up...');
    
    const allEntries = useAppStore.getState().entries;
    
    const junkKeywords = ['represent', 'visualize', 'show a', 'e.g.', 'could be', 'by showing', 'depict', 'as a'];

    const entriesToClean = allEntries.filter(entry => {
        // SAFETY PROTOCOL: First and most important check.
        // If the user marked it as 'good', we NEVER touch it.
        if (entry.qaScore === 'good') {
            return false;
        }

        const prompt = entry.prompt?.toLowerCase() || '';
        if (!prompt) return false;
        
        // Criteria for a bad prompt: contains junk keywords or is abnormally long.
        return prompt.length > 50 || junkKeywords.some(keyword => prompt.includes(keyword));
    });

    if (entriesToClean.length === 0) {
        toast.info('No actionable descriptive prompts found to clean up.');
        activityManager.addActivity('info', 'Cleanup not needed. No unapproved descriptive prompts found.');
        return;
    }

    activityManager.addActivity('info', `Found ${entriesToClean.length} prompts to clean. Starting process...`);

    const result = await processBatch({
        itemsToProcess: entriesToClean,
        batchSize: 20,
        delayBetweenBatchesMs: 200,
        operationName: 'Descriptive Prompts Cleanup',
        getBatchPayload: (batch) => ({
            entries: batch.map(e => ({
                id: e.id,
                english: e.original_text,
                russian: e.translation_text,
                transcription: e.transcription,
            })),
        }),
        batchApiService: generatePromptsBatchService,
        getSuccessItems: (data) => data.prompts || [],
        getErrorItems: (data) => data.errors || [],
        onStartProcessingItem: (entry) => {
            updateEntry(entry.id, { promptStatus: 'generating' });
        },
        processItemSuccess: (result, originalEntry) => {
            // Update the entry according to the safety protocol.
            // DO NOT modify imageUrl.
            updateEntry(result.id, {
                prompt: result.prompt,
                promptStatus: 'completed',
                qaScore: null,
                imageStatus: 'none', 
            });
        },
        processItemError: (error, originalEntry) => {
            if (originalEntry) {
                updateEntry(originalEntry.id, { promptStatus: 'error' });
            }
        },
    });

    const message = `Cleaned up ${result.totalSuccess} descriptive prompts. ${result.totalFailed > 0 ? `${result.totalFailed} failed.` : ''}`;
    activityManager.addActivity('info', message);
    toast.success(message);
  };

  const columns = useMemo<ColumnDef<WordEntry>[]>(
    () => [
      {
        accessorKey: 'id',
        header: 'ID',
        size: 60,
      },
      {
        accessorKey: 'original_text',
        header: 'English',
        size: 200,
      },
      {
        accessorKey: 'transcription',
        header: 'Transcription',
        size: 180,
      },
      {
        accessorKey: 'translation_text',
        header: 'Russian',
        size: 200,
      },
      {
        accessorKey: 'level_id',
        header: 'Level',
        size: 60,
      },
      {
        id: 'category',
        header: 'Category',
        size: 140,
        cell: ({ row }) => {
          const entry = row.original;
          if (!entry.categorization || entry.categorizationStatus !== 'completed') {
            return <span className="text-gray-500 text-xs">-</span>;
          }
          
          const categoryMap = {
            'CONCRETE-VISUAL': { label: 'Concrete', color: 'text-green-500' },
            'ABSTRACT-SYMBOLIC': { label: 'Abstract', color: 'text-blue-500' },
            'ACTION-VISUAL': { label: 'Action', color: 'text-orange-500' },
            'STATE-METAPHORICAL': { label: 'State', color: 'text-purple-500' }
          };
          
          const category = categoryMap[entry.categorization.primary_category];
          const suitability = entry.categorization.image_suitability;
          
          return (
            <div className="flex flex-col gap-1">
              <span className={`text-xs font-medium ${category.color}`}>
                {category.label}
              </span>
              <span className={`text-xs ${
                suitability === 'HIGH' ? 'text-green-400' : 
                suitability === 'MEDIUM' ? 'text-yellow-400' : 
                'text-red-400'
              }`}>
                {suitability}
              </span>
            </div>
          );
        },
      },
      {
        id: 'hasImage',
        header: 'Image',
        size: 80,
        cell: ({ row }) => {
          const entry = row.original;
          const hasImage = entry.imageUrl && entry.imageStatus === 'completed';
          
          return (
            <div className="flex items-center justify-center">
              {hasImage ? (
                <div className="flex items-center gap-1 text-green-600">
                  <ImageIcon className="h-4 w-4" />
                  <span className="text-xs">‚úì</span>
                </div>
              ) : (
                <span className="text-gray-500 text-xs">-</span>
              )}
            </div>
          );
        },
      },
      {
        id: 'qaScore',
        header: 'QA',
        size: 60,
        cell: ({ row }) => {
          const entry = row.original;
          
          return (
            <div className="flex items-center justify-center">
              {entry.qaScore === 'good' ? (
                <span className="text-green-600 text-sm">‚úÖ</span>
              ) : entry.qaScore === 'bad' ? (
                <span className="text-red-600 text-sm">‚ùå</span>
              ) : (
                <span className="text-gray-500 text-xs">-</span>
              )}
            </div>
          );
        },
      },
      {
        accessorKey: 'prompt',
        header: 'Prompt',
        size: 280,
        cell: ({ row }) => {
          const entry = row.original;
          const isEditing = editingId === entry.id;

          if (isEditing) {
            return (
              <div className="flex items-center gap-2">
                <input
                  type="text"
                  value={editingPrompt}
                  onChange={(e) => setEditingPrompt(e.target.value)}
                  className="input-field flex-1 text-xs"
                  placeholder="Enter prompt..."
                />
                <button
                  onClick={() => handleSavePrompt(entry.id)}
                  className="p-1 rounded hover:bg-gray-800"
                >
                  <Save className="h-4 w-4 text-green-600" />
                </button>
                <button
                  onClick={handleCancelEdit}
                  className="p-1 rounded hover:bg-gray-800"
                >
                  <X className="h-4 w-4 text-red-600" />
                </button>
              </div>
            );
          }

          return (
            <div className="flex items-center gap-2 min-w-0">
              <span className="text-sm truncate block min-w-0 text-gray-300" title={entry.prompt || ''}>
                {entry.prompt || <span className="text-gray-500">No prompt</span>}
              </span>
              <button
                onClick={() => handleEditPrompt(entry)}
                className="p-1 rounded opacity-0 group-hover:opacity-100 transition-opacity hover:bg-gray-800 flex-shrink-0"
              >
                <Edit2 className="h-3 w-3 text-gray-400" />
              </button>
            </div>
          );
        },
      },
      {
        id: 'actions',
        header: 'Actions',
        size: 260,
        cell: ({ row }) => {
          const entry = row.original;
          
          return (
            <div className="flex items-center gap-2">
              <button
                onClick={() => handleGeneratePrompt(entry)}
                disabled={entry.promptStatus === 'generating'}
                className="btn-secondary"
              >
                {entry.promptStatus === 'generating' ? (
                  <div className="loading-spinner" />
                ) : (
                  <>
                    <Sparkles className="h-3 w-3" />
                    [PROMPT]
                  </>
                )}
              </button>
              
              <button
                onClick={() => handleGenerateImage(entry)}
                disabled={!entry.prompt || (entry.imageStatus === 'processing' || entry.imageStatus === 'queued')}
                className="btn-primary"
              >
                {entry.imageStatus === 'processing' || entry.imageStatus === 'queued' ? (
                  <div className="loading-spinner" />
                ) : (
                  <>
                    <ImageIcon className="h-3 w-3" />
                    [IMAGE]
                  </>
                )}
              </button>
            </div>
          );
        },
      },
    ],
    [editingId, editingPrompt]
  );

  const table = useReactTable({
    data: filteredData,
    columns,
    state: {
      sorting,
      pagination: {
        pageIndex: currentPage - 1,
        pageSize: itemsPerPage,
      },
    },
    onSortingChange: setSorting,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    manualPagination: false,
    pageCount: Math.ceil(filteredData.length / itemsPerPage),
  });

  return (
    <div className="space-y-4">
      {/* Filters */}
      <div className="flex gap-4 items-center">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-500" />
          <input
            type="text"
            placeholder="Search entries..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="input-field pl-9"
          />
        </div>
        
        <select
          value={promptFilter}
          onChange={(e) => setPromptFilter(e.target.value as 'all' | 'with' | 'without')}
          className="input-field w-40"
        >
          <option value="all">All Prompts</option>
          <option value="with">With Prompts</option>
          <option value="without">Without Prompts</option>
        </select>

        <select
          value={imageFilter}
          onChange={(e) => setImageFilter(e.target.value as 'all' | 'with' | 'without' | 'bad')}
          className="input-field w-40"
        >
          <option value="all">All Images</option>
          <option value="with">With Images</option>
          <option value="without">Without Images</option>
          <option value="bad">‚ùå Bad Images</option>
        </select>

        <select
          value={categorizationFilter}
          onChange={(e) => setCategorizationFilter(e.target.value as 'all' | 'uncategorized' | 'categorized')}
          className="input-field w-48"
        >
          <option value="all">All Categories</option>
          <option value="uncategorized">Uncategorized (Needs TIAC)</option>
          <option value="categorized">Categorized (TIAC Done)</option>
        </select>

        <select
          value={suitabilityFilter}
          onChange={(e) => setSuitabilityFilter(e.target.value as 'all' | 'HIGH' | 'MEDIUM' | 'LOW')}
          className="input-field w-48"
        >
          <option value="all">All Suitabilities</option>
          <option value="HIGH">High Suitability</option>
          <option value="MEDIUM">Medium Suitability</option>
          <option value="LOW">Low Suitability</option>
        </select>

        {/* Batch Generate Prompts Menu */}
        <BatchActionMenu
          triggerButtonLabel="Batch Generate"
          triggerButtonIcon={<Sparkles className="h-4 w-4" />}
          menuTitle="Generate prompts for:"
          countInputState={[customBatchGenerateCount, setCustomBatchGenerateCount]}
          onCustomCountAction={handleCustomBatchGeneratePrompts}
          customCountActionLabel={(count) => `Generate First ${count || 'N'} Prompts`}
          onAllEligibleAction={() => {
            const allWithoutPromptsCount = filteredData.filter(e => !e.prompt || e.prompt.trim() === '').length;
            if (allWithoutPromptsCount > 0) {
              handleBatchGeneratePrompts(allWithoutPromptsCount);
            } else {
              toast.error('No entries without prompts found');
            }
          }}
          allEligibleActionLabel="All without prompts"
          getEligibleCount={() => filteredData.filter(e => !e.prompt || e.prompt.trim() === '').length}
        />

        {/* Categorization Menu */}
        <BatchActionMenu
          triggerButtonLabel="Categorize (TIAC)"
          triggerButtonIcon={<Filter className="h-4 w-4" />}
          menuTitle="Categorize vocabulary for:"
          countInputState={[customCategorizeCount, setCustomCategorizeCount]}
          onCustomCountAction={handleCustomBatchCategorize}
          customCountActionLabel={(count) => `Categorize First ${count || 'N'} Words`}
          onAllEligibleAction={() => {
            const allWithoutCategorization = filteredData.filter(e => !e.categorization || e.categorizationStatus !== 'completed').length;
            handleBatchCategorize(allWithoutCategorization);
          }}
          allEligibleActionLabel="All uncategorized"
          getEligibleCount={() => filteredData.filter(e => !e.categorization || e.categorizationStatus !== 'completed').length}
        />

        {/* Batch Images Menu */}
        <BatchActionMenu
          triggerButtonLabel="Batch Images"
          triggerButtonIcon={<ImageIcon className="h-4 w-4" />}
          menuTitle="Generate images for first:"
          countInputState={[customImageBatchCount, setCustomImageBatchCount]}
          onCustomCountAction={handleCustomBatchGenerateImages}
          customCountActionLabel={(count) => `Generate for ${count || 'N'} (Eligible)`}
          onAllEligibleAction={handleBatchGenerateAllEligibleImages}
          allEligibleActionLabel="All eligible"
          getEligibleCount={() => filteredData.filter(entry => 
            entry.prompt && 
            entry.prompt.trim() !== '' && 
            entry.imageStatus !== 'queued' && 
            entry.imageStatus !== 'processing' && 
            (!entry.imageUrl || entry.imageStatus !== 'completed') && !entry.qaScore
          ).length}
        />

        {/* Refresh Bad Prompts Button */}
        <button
          onClick={handleBatchRefreshBadPrompts}
          disabled={filteredData.filter(entry => entry.qaScore === 'bad').length === 0}
          className="btn-secondary flex items-center gap-2"
          title="Generate new prompts for all bad entries"
        >
          <RefreshCcw className="h-4 w-4" />
          Refresh Bad Prompts ({filteredData.filter(entry => entry.qaScore === 'bad').length})
        </button>

        {/* Regenerate Bad Images Button */}
        <button
          onClick={handleBatchRegenerateBadImages}
          disabled={filteredData.filter(entry => entry.qaScore === 'bad').length === 0}
          className="btn-secondary bg-purple-600 hover:bg-purple-700 text-white flex items-center gap-2"
          title="Regenerate images for all bad entries using their existing prompts"
        >
          <ImageIcon className="h-4 w-4" />
          Regen Bad Images ({filteredData.filter(entry => entry.qaScore === 'bad').length})
        </button>

        {/* Clear Queue Button */}
        <button
          onClick={handleClearQueue}
          className="btn-secondary bg-red-600 hover:bg-red-700 text-white flex items-center gap-2"
          title="Clear all items from the image generation queue"
        >
          <X className="h-4 w-4" />
          Clear Queue
        </button>

        {/* Cleanup Descriptive Prompts Button */}
        <button
          onClick={handleCleanupDescriptivePrompts}
          className="btn-primary bg-orange-600 hover:bg-orange-700 flex items-center gap-2"
          title="Find and regenerate all unapproved prompts that are descriptive sentences instead of objects."
        >
          <Sparkles className="h-4 w-4" />
          Cleanup Descriptive Prompts
        </button>
      </div>

      {/* Table */}
      <div className="overflow-x-auto rounded-lg border border-gray-700">
        <table className="w-full table-fixed">
          <thead>
            {table.getHeaderGroups().map((headerGroup) => (
              <tr key={headerGroup.id} className="table-header">
                {headerGroup.headers.map((header) => (
                  <th
                    key={header.id}
                    className="px-4 py-3 text-left cursor-pointer hover:bg-gray-800"
                    style={{ width: header.getSize() }}
                    onClick={header.column.getToggleSortingHandler()}
                  >
                    <div className="flex items-center gap-1">
                      {flexRender(header.column.columnDef.header, header.getContext())}
                      {header.column.getIsSorted() && (
                        header.column.getIsSorted() === 'asc' ? (
                          <ChevronUp className="h-3 w-3" />
                        ) : (
                          <ChevronDown className="h-3 w-3" />
                        )
                      )}
                    </div>
                  </th>
                ))}
              </tr>
            ))}
          </thead>
          <tbody>
            {table.getRowModel().rows.map((row) => (
              <tr key={row.id} className="table-row group">
                {row.getVisibleCells().map((cell) => (
                  <td key={cell.id} className="px-4 py-3 text-sm" style={{ maxWidth: cell.column.getSize() }}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Pagination */}
      <div className="flex items-center justify-between">
        <div className="text-sm text-gray-400">
          Showing {Math.min((currentPage - 1) * itemsPerPage + 1, filteredData.length)} to {Math.min(currentPage * itemsPerPage, filteredData.length)} of {filteredData.length} entries
        </div>
        <div className="flex gap-2">
          <button
            onClick={() => {
              table.previousPage();
              setCurrentPage(currentPage - 1);
            }}
            disabled={!table.getCanPreviousPage()}
            className="btn-secondary"
          >
            ‚Üê PREV
          </button>
          <span className="flex items-center px-3 text-sm text-gray-400">
            Page {table.getState().pagination.pageIndex + 1} of {table.getPageCount()}
          </span>
          <button
            onClick={() => {
              table.nextPage();
              setCurrentPage(currentPage + 1);
            }}
            disabled={!table.getCanNextPage()}
            className="btn-secondary"
          >
            NEXT ‚Üí
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

</files>
